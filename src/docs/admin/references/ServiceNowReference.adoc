*Product Name:* ServiceNow +
*Product Version:* Quebec +
*Compatibility:* Tokyo

==== Overview

The ServiceNow integration provides means to establish a bidirectional communication
between a ProActive server, and a ServiceNow instance.

==== Objectives

The goal is to provide templates and coding elements to help ServiceNow and ProActive engineers to easily integrate both solutions in their pipelines.

It boils down to: +

* Provide reusable code in ServiceNow to query ProActive's REST APIs.
* Provide workflows in ProActive's catalog to query ServiceNow's REST APIs.

==== Installation

This section describes the available processes to set up the required files in ServiceNow in order to communicate
with ProActive. The process choice is dictated by the architecture the integration will have in ServiceNow. Because ServiceNow
is application-based, the natural course of action is to create a dedicated ProActive application.
Otherwise, you might want to incorporate this integration in another application that already exists. In such case,
you will have to manually create files in the host application, which means copy-paste code that will be presented in the next sections.

===== Import from source control

Working from an online repository is the most convenient and durable way to proceed.
Importing an application from source control will result in a new application being created in this ServiceNow instance based on the remote repository you specify.
The account credentials you supply must have read access to the remote repository

. [.underline]#Lay down the Application#
    .. Fork the https://bitbucket.org/activeeon/proactive-application[Application's repository]
    .. Go to the Studio, under _System Applications_ -> _Studio_
+
image::servicenow-studio-select.png[align="center"]
    .. Click _Import from source control_
+
image::servicenow-import-from-source-control.png[align="center"]
    .. Click _Import_. When the application import is completed, click the _Select Application button_.
+
image::servicenow-imported-from-source-control.png[align="center"]
    .. In the Select Application dialog, click the link to the new application to open it for editing in Studio.

Because you will very likely customize the application, it's a good idea to create a new branch an start working from there

[start=2]
. [.underline]#Create a new branch#
.. In Studio, open the _Source Control_ menu and select the _Create Branch_ menu item.
+
image::servicenow-create-branch.png[align="center"]
.. Configure the branch.

    Branch Name: branchName
    Create from Tag: -- None --

.. Click the _Create Branch_ button.
.. Click the _Close_ button.

To load the application files included in the tag, return to the main ServiceNow browser tab (not Studio) and click the browser's reload button to refresh the page.

===== Upload an Update Set

Though not recommended by ServiceNow, you can download the following Update Set and import it in a ServiceNow instance
to create an application. An Update Set describes and contains all application's files and is specific to ServiceNow.

. link:../admin/references/servicenow/update_set_21813bcd2f9c91103c5d9facf699b605.xml[Download the Update Set].
. Go to _Retrieved Update Sets_ under _System Update Sets_
. Click on _Import Update Set from XML_
. Select the Update Set you just downloaded
. Click on _Upload_ and wait for the upload to complete

The Retrieved Update Set table should be displayed with the freshly uploaded file named _ProActive Workflows & Scheduling_

[start=6]
. Click on the Update Set Name to open it.
. Click on _Preview Update Set_ and wait for the preview to finish. +
This step is important as it compares an update set retrieved from a remote instance to
updates on the local instance to detect potential conflicts. You must preview an update set and address all problems before you can commit the update set.
. Once finished, click on _Close_
. Problems will appear because some tables and records don't exist in your instance and ServiceNow doesn't like that.
That's because we are installing an application and not updating it. We can ignore them and commit the changes.
.. Select all errors by clicking on the top left checkbox (this selects all the displayed errors)
.. Click on _Accept remote changes_ on the top right
+
image::servicenow-accept-remote-update.png[align="center"]
.. Repeat step a. and b. if errors remain
. Once all problems have been addressed. Click _Commit Update Set_.
. Click Confirm data loss and wait for the commit to finish
. Once again, and for the same reason ServiceNow will inform us of errors.
.. Click on _Show Commit Log_ and check that all records are of "Info" status.

Set a filter as shown and click on _Run_ to apply it.

image::servicenow-search-by-status.png[align="center"]
Result should be empty.


==== Communicate with ProActive

Once the application installed, you are ready to integrate ProActive in your ServiceNow pipelines.

We will go over the core application files in the application, what they do and how to use them.

===== Script include

====== Overview

As defined by ServiceNow, Script Includes are reusable server-side script logic that define a function or class.
Script Includes execute their script logic only when explicitly called by other scripts anywhere in the application where scripting is permitted.

It can be in another Script Include, In Worfklow Activities, Flow Actions, UI elements ...

====== Usage

Calling a Script Include where scripting is enabled is very easy. You just need to create an instance of the Script Include and execute its functions.

Here is an example where the Script Include named SchedulerClient is called in a Flow's Action to submit a job:

[[submit_from_catalog_script_code]]
[source,javascript]
----
(function execute(inputs, outputs) {

    var schedulerClient = new SchedulerClient();
    var response = schedulerClient.submitJobFromCatalog(inputs.proactive_url, inputs.session_id, inputs.bucket_name, inputs.workflow_name, inputs.variables, inputs.generic_info);

    outputs.job_id = response.id;
    outputs.readable_name = response.readableName;

})(inputs, outputs);
----

====== ProActive's application Script Includes

There are 3 script includes in the ProActive application:

*SchedulerClient*: A client that makes REST calls to a ProActive's Scheduler.
Call this Script Include to make HTTP requests to the Scheduler of a ProActive's server.

Here is the list of its current functions.

TIP: The REST API documentation for our try platform is available at https://try.activeeon.com/doc/rest/

[cols="1,1,1,1"]
|===
|Function name | Action | Inputs | Output

|getSessionId
|Executes a POST request to login and retrieve the sessionId of a ProActive user
a|
* proActiveUrl: Root URL of ProActive server
* username: Name of user
* password: Password of user
|The session id associated to the user

|restartInErrorTasks
|Executes a PUT request to restart all tasks in error in the job represented by a job id
a|
* jobId: Id of the job to restart in error tasks
|True if success, false if not

|submitJobFromCatalog
|Submits a workflow to the scheduler from a workflow URL, creating a new job resource
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: sessiondId of the user that will submit the job
* bucket: Bucket name of the workflow
* workflow: Name of the workflow
* workflowVariables: Variables of the workflow as a JSON
* genericInfos: Generic informations of the workflow as JSON
a|The jobid of the newly created job as JSON

[source,json]
----
{
  readableName:string,
  id:integer
}
----

|submitJobFromFile
|Submits a workflow stored in the ServiceNow instance to ProActive's scheduler, creating a new job resource.
Provided a workflow name, the script will search for the corresponding workflow stored in ProActive's application table named "x_661207_proacti_0_workflow" and labeled "Workflow".
The workflow's must be stored as a file that complies with ProActive's xref:../user/ProActiveUserGuide.adoc#_job_and_task_specification[XML schema].
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: Session id of the ProActive who submits the job
* workflowName: Name of the workflow to submit, stored in the Workflow table
* variables: Variables of the workflow as JSON
a|The jobid of the newly created job as JSON

[source,json]
----
{
  readableName:string,
  id:integer
}
----

|disconnectUser
|Executes a PUT request to disconnect a user represented by a sessionId from a ProActive server
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: Session id of the user to disconnect
|True if successful else false

|getJobInfo
|Executes a GET request to retrieve a job's job info
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: Session id of the ProActive user
|True if successful, else false

|isFaultyJob
|Executes the getJobInfo function and checks the current job status to determine if the job is Faulty.
A job is considered faulty when it is finished, canceled or failed and has at least one task that is failed, faulty or in error
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: Session id of the ProActive user
* jobId: Id of the job to test
|True if the job is faulty, else false

|waitForTerminalStatus
|Polling function that blocks the current thread and checks the current job status every 2.5 seconds until it reaches a terminal status.
a|
* proactiveUrl: Root URL of ProActive server
* sessionId: Session id of the ProActive user
* jobId: Id of the job to poll
|The polled job info

|_getAllJobStatuses
|Utility function that returns a mapping of all the possible job statuses and if it is a terminal status
|
a|
[source,json]
----
{
    'PENDING': true,
    'RUNNING': true,
    'STALLED': true,
    'FINISHED': false,
    'PAUSED': true,
    'CANCELED': false,
    'FAILED': false,
    'KILLED': false,
    'IN_ERROR': true
}
----
|Cell in column 4, row 3
|===

[NOTE]
Functions starting with an _ is a ServiceNow naming convention for private functions. This is purely informative
as in reality they are callable from anywhere like other functions.

*OutboundRestService*: A service class that contains a utility function to execute a ServiceNow's Outbound Rest Messages.
Used by the SchedulerClient, it encapsulates the procedure to build and execute an HTTP query to ProActive's Scheduler.

Like the SchedulerClient class, its function can be called from anywhere scripting is permitted.

[cols="1,1,1,1"]
|===
|Function name | Action | Inputs | Output

| executeOutboundRestMsg
| Prepares and executes a ServiceNow HTTP Method from the ProActive Scheduler REST Message
a|
* proActiveUrl: Root URL of ProActive server
* sessionId: Session id of the ProActive user
* httpMethodName: Name of the HTTP Method to execute
* httpMethodVariables: A JSON collection of name/value pairs which holds the name of the HTTP Method variable to replace and its value.
This stands for all HTTP params types (including variables in the body) except query params which are defined in the following variable.
* queryParams: A JSON collection of name/value pairs which holds the name of the query param to replace and its value.
| A RESTResponseV2 object. Go to ServiceNow's link:https://developer.servicenow.com/dev.do#!/reference/api/quebec/server/sn_ws-namespace/c_RESTResponseV2API[RESTResponseV2 API documentation]
to get a list of its functions.
|Cell in column 4, row 3
|===

*JobRepository*: It is the service class which holds functions to perform CRUD operations on the application's table labeled "Submitted job".
A table is a collection of records in the database. Each record corresponds to a row in a table, and each field on a record corresponds to a column on that table.
The Submitted Job table can be used to store Job Info data received from ProActive and access it in your pipelines.
Like other Script Include, it can be instantiated and called anywhere scripting is permitted.

You will find in the next section the structure of the table, which corresponds to JobInfo data fields returned by the Scheduler.

Here is the list of the current available functions

[cols="1,1,1,1"]
|===
|Function name | Action | Inputs | Output

| createSubmittedJob
| Adds a row to the Submitted Job table
a|
* sessionId: Session id of the ProActive user
* jobInfo: JobInfo data object to insert in the table
| The sys id of the created row

| updateSubmittedJob
| updates a row to the Submitted Job table
a|
* sessionId: Session id of the ProActive user
* jobInfo: Complete JobInfo data object with updated fields.
| True if the update has succeeded, else false

| deleteSubmittedJobBySysId
| Deletes a row which has the specified sys id
a|
* sysId: The sys id of the row to be deleted
| True if the deletion has succeeded, else false

| deleteSubmittedJobByJobId
| Deletes a row which has the specified job id
a|
* jobId: The id of the job to be deleted
| True if the deletion has succeeded, else false

| _isJobExists
| Checks if a row exists with the specified job id
a|
* jobId: The id of the job to check
| True if the row exists, else false

| _executeUpdateQuery
| Utility function to encapsulate the update of a row process
a|
* jobId: The id of the job to be updated
| True if the update has succeeded, else false
|Cell in column 4, row 3
|===

===== Tables

The application has two tables that can be used to store and read data:

. *Submitted Job*: Each row contains data of a job submitted to the Scheduler.
This is the table used by the JobRepository Script Include to perform CRUD operations.
. *Workflow*: Each row contains a ProActive workflow xml definition file. The function submitJobFromFile of the SchedulerService Script Include
will search for the specified workflow xml definition in this table.

Below you will find the structure of both tables

.Structure of the Submitted Job table
[cols="1,1,1"]
|===
|Column name | Type | Max length

| finished_time
| Long
| 40

| in_error_time
| Long
| 40

| job_id
| Long
| 40

| name
| String
| 256

| output
| String
| 4000

| owner
| String
| 40

| result
| String
| 40

| session_id
| String
| 64

| start_time
| Long
| 40

| status
| String
| 16

| submitted_time
| Long
| 40
|===

.Structure of the Workflow table
[cols="1,1,1"]
|===
|Column name | Type | Max length

| name
| String
| 256

| file
| File Attachment
| 40

|Cell in column 4, row 3
|===

[NOTE]
All tables contain additional fields starting with sys_ . Those fields are automatically generated by ServiceNow when the table is created and can't be changed.

Two Table Columns have been added to the Incident table:

. ProActive Job Id
. ProActive Session Id

This allows to specify the sessionId of the user, and a job id at an Incident creation, binding it to a ProActive job.
Other columns can be added in the Incident table to store logs, outputs or any needed information regarding a job.

===== Flow Designer

Flow Designer is a feature for automating processes in a single design environment.

Actions and Core Actions are what composes a Flow and Subflow. The application comes with Actions ready to be used.
These Actions use the Script Includes that we described earlier.

An Action consists of:

- Inputs: Variables accessible from all steps of the action
- Action step(s): Process(es) using the provided inputs
- Outputs: Variables that represent the results of the action. These results are available to other actions in a flow.

ProActive's application Actions have been designed so that their inputs correspond to the related function called from
the Scheduler Client Script Include to make it as linear as possible.

.Available actions
[.center, cols="1", width=25%]
|===
|Action name

| Login to ProActive
| Disconnect from ProActive
| Submit job from catalog
| Submit job from file
| Wait for terminal status
| Disconnect from ProActive
|===

Here is an example with the "Submit From Catalog" action. Principles are the same for other actions

.Inputs of the Submit From Catalog action
image::servicenow-action-inputs.png[align="center"]

The Action inputs are accessible by all steps of the Action

Inputs of this step are bound to the Action inputs. This is represented by a pill
in the "Value" column.

.Inputs of the Submit From Catalog script step
image::servicenow-step-inputs.png[align="center"]

The action is composed of a single Script step. A script step is JavaScript code to execute within a reusable action.
While most core actions and steps fit common use cases, a Script step enables to execute behavior not satisfied by the core steps.

The code of this script step is displayed <<submit_from_catalog_script_code, here>>.

As you can see it is very simple and the execution flow consists of:

. Instantiating the SchedulerClient Script Include
. Calling the submitFromCatalog function with the inputs as parameters
. Writing the result in the outputs variable

Finally, we define the outputs of the action with the same pills system, binding them to the step outputs.

.Outputs of the Submit From Catalog Action
image::servicenow-action-outputs.png[align="center"]

The concept is the same for all the application's Actions.

===== Flows

To put it simply a flow is an automated process consisting of a sequence of actions and a trigger.
Flow building takes place in the Flow Designer application which requires a paid subscription to the Integration Hub application.

A Flow consists of the content types:

- Subflows: A Subflow is an automated process consisting of a sequence of reusable actions and specific data inputs that allow the process to be started from a flow, subflow, or script.
- Actions: An Action is a reusable operation that enables process analysts to automate Now Platform features without having to write code
- Core Actions: A ServiceNow Core Action is a ServiceNow-provided action available to any flow that cannot be viewed or edited from the Action Designer design environment.
For example, the Ask for Approval action

A trigger identifies what causes the flow to execute. +

Flows are triggered by:

- Record creation and/or update
- Date
- Service Catalog request
- Inbound email
- Service Level Agreements
- MetricBase (requires the MetricBase plugin)

[NOTE]
To access Flows, a user must have the flow_designer or admin roles.

The ProActive application come with Flows that can:

- Submit a job from the catalog asynchronously
- Restart in error tasks

Below is the "Submit job from catalog async" Flow

image::servicenow-flow.png[align="center"]

This Flow submits a job to ProActive's Scheduler in parallel, thus not blocking the main Flow thread.

In the Right panel named Data, you will find the data flow of the Flow. It offers a quick view of the Flow variables, accessible by all actions
and the inputs for each Action. Fo convenience, it has been cut in half in this screenshot.

image::servicenow-data-flow-flow-designer.png[align="center"]

The flow needs a trigger definition, and it will ready to run.

===== Workflows

The second way to automate complex processes is using Workflows that are built in the Workflow Editor.
A Workflow is the native way to do automation in ServiceNow. Workflow editor is intended for a more technical audience.

The goal and concepts of Workflows are the same as Flows only with a different interface and terminology.

Like Actions for Flows, a Workflow is a suite of Activities used for automating the processes.
Activities are the workflow blocks that carry out various tasks like sending emails, obtaining approvals, running scripts, and configuring field values on the records.

Every workflow starts with a Begin activity and ends with the End activity.
When the activity ends, the activity is available through the suitable node and transition is comprehended to the later activity.

Following are the ways to launch Workflows:

- UI Action
- Server-side script
- Triggered by field values on a record

The ProActive application comes with a set of activities ready to be used in your workflows.
Like the Actions in the Flows, they call the application's Script Include to perform their actions.

Each activity likely have inputs that needs to be defined.

Here the Login activity will read variables defined in the workflow's scratchpad.

image::servicenow-activity-variables.png[align="center"]

This window automatically opens when the activity is dragged and dropped on the canvas.

Use ProActive's custom activities from the Custom tab to integrate ProActive in your pipelines.

Here an example of a simple Workflow, that can be stored and used as a Sub Workflow, that Submits a job to ProActive from the Catalog

image::servicenow-workflow-example.png[align="center"]
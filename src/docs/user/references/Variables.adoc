
Variables can come at hand while developing ProActive applications.
Propagate data between tasks, customize jobs, and store useful debug information are a few examples of
how variables can ease development. ProActive has basically two groups of variables:

- <<_workflow_variables>>, declared on the XML job definition.
- <<_dynamic_variables>>, system variables or variables created at task runtime.

[[_workflow_variables]]
==== Workflow variables

Workflow variables are declared in the XML job definition. Within the definition we can have variables in several
levels, at job level the variables are visible and shared by all tasks. At task level, variables are visible
only within the task execution context.

[[_job_variables]]
===== Job variables

In a workflow, you can define *job variables* that are shared and visible by all tasks.

A job variable is defined using the following attributes:

* *name*: the variable name.
* *value*: the variable value.
* *model*: the variable value type or model (optional). See section <<_variable_model,Variable Model>>.
* *description*: the variable description (optional). The description can be written using html syntax (e.g. `This variable is <b>mandatory</b>.`).
* *group*: the group name associated with the variable (optional). When the workflow has many variables,
defining variable groups helps understanding the various parameters. Variables with no associated group are called _Main Variables_.
* *advanced*: when a variable is advanced, it is not displayed by default in the workflow submission form.
A checkbox allows the user to display or hide advanced variables.
* *hidden*: a hidden variable is not displayed to the user in the workflow submission form. Hidden variables have the following usages:
** perform _hidden checks_ on other variables, defined by a variable model _SpEL expression_, see <<_variable_model>> and <<_spring_expression_language_model>>.
** build _dynamic forms_ where variables are displayed or hidden depending on the values of other variables, see <<_variable_model>>, <<_spring_expression_language_model>> and <<_dynamic_forms>>.

[[_templating]]
Variables are very useful to use workflows as templates where only a few parameters change for each
execution. Upon submission you can define variable values in several ways from <<_scheduler_command_line, CLI>>,
using the ProActive Workflow Studio, directly editing the XML job definition, or even using REST
API.

The following example shows how to define a job variable in the XML:
[source, xml]
----
<job ... >
    <variables>
        <variable name="variable" value="value" model=""/>
    </variables>
    ...
</job>
----

*Job variables* can be referenced anywhere in the workflow, including other job variables.

The syntax for referencing a variable is the pattern `${variable_name}` (case-sensitive), for example:

[source, xml]
----
<nativeExecutable>
    <staticCommand value="${variable}" />
</nativeExecutable>
----

===== Task variables

Similarly to job variables, *Task variables* can be defined within task scope in the job XML definition.
Task variables scope is strictly limited to the task definition.

A task variable is defined using the following attributes:

* *name*: the variable name.
* *value*: the variable value.
* *inherited*: asserts when the content of this variable is propagated from a <<_job_variables,job variable>> or a <<_inherited_variables,parent task>>.
If _true_, the value defined in the task variable will only be used if no variable with the same name is propagated. Value field can be left empty however it can
also work as a default value in case a previous task fails to define the variable.
* *model*: the variable value type or model (optional). See section <<_variable_model,Variable Model>>
* *description*: the variable description (optional). The description can be written using html syntax (e.g. `This variable is <b>mandatory</b>.`).
* *group*: the group name associated with the variable (optional). When the workflow has many variables,
defining variable groups helps understanding the various parameters. Variables with no associated group are called _Main Variables_.
* *advanced*: when a variable is advanced, it is not displayed by default in the workflow submission form.
A checkbox allows the user to display or hide advanced variables.
* *hidden*: a hidden variable is not displayed to the user in the workflow submission form. Hidden variables have the following usages:
** perform _hidden checks_ on other variables, defined by a variable model _SpEL expression_, see <<_variable_model>> and <<_spring_expression_language_model>>.
** build _dynamic forms_ where variables are displayed or hidden depending on the values of other variables, see <<_variable_model>>, <<_spring_expression_language_model>> and <<_dynamic_forms>>.

For example:
[source, xml]
----
<task ... >
    <variables>
        <variable name="variable" value="value" inherited="false" model=""/>
    </variables>
    ...
</task>
----
Task variables can be used similarly to job variables using the pattern `${variable_name}` but only inside the task where the variable is defined.

Task variables *override* job variables, this means that if a job variable and a task variable are defined with the same name, the task variable value will be used inside the task (unless the task variable is marked as *inherited*), and the job variable value will be used elsewhere in the job.

===== Global Variables

Global variables are *job variables* that are configured inside ProActive server and apply to all workflows or to certain categories of workflows (e.g. workflows with a given name).

See link:../admin/ProActiveAdminGuide.html#_configure_global_variables_and_generic_information[Configure Global Variables and Generic Information] section to understand how global variables can be configured on the ProActive server.

===== Variable Model

Job and Task variables can define a `model` attribute which let the workflow designer control the variable value syntax.
A workflow designer can for example decide that the variable NUMBER_OF_ENTRIES is expected to be convertible to an Integer ranged between 0 and 20.

The workflow designer will then provide a default value to the variable NUMBER_OF_ENTRIES, for example "10". This workflow is valid as "10" can be converted to an Integer and is between 0 and 20.

When submitting the workflow, it will be possible to choose a new value for the variable NUMBER_OF_ENTRIES.
If the user submitting the workflow chooses for example the value -5, the validation will fail and an error message will appear.

====== Available Models

The following list describes the various model syntaxes available:

. Main variable models

* *PA:INTEGER* , *PA:INTEGER[min,max]* : variable can be converted to https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Integer.html[java.lang.Integer], and eventually is contained in the range [min, max]. +
Examples: PA:INTEGER will accept "-5" but not "1.4", PA:INTEGER[0,20] will accept "12" but not "25".
* *PA:LONG* , *PA:LONG[min,max]* : same as above with https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Long.html[java.lang.Long].
* *PA:FLOAT* , *PA:FLOAT[min,max]* : same as above with https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Float.html[java.lang.Float]. +
Examples: PA:FLOAT[-0.33,5.99] will accept "3.5" but not "6".
* *PA:DOUBLE* , *PA:DOUBLE[min,max]* : same as above with https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Double.html[java.lang.Double].
* *PA:SHORT* , *PA:SHORT[min,max]* : same as above with https://docs.oracle.com/javase/7/docs/api/index.html?java/lang/Short.html[java.lang.Short].
* *PA:BOOLEAN* : variable is either "true", "false", "0" or "1".
* *PA:NOT_EMPTY_STRING* : variable must be provided with a non-empty string value.
* *PA:HIDDEN* : variable which allows the user to securely enter his/her value (i.e., each character is shown as an asterisk, so that it cannot be read.) while submitting the workflow.
* *PA:URL* : variable can be converted to https://docs.oracle.com/javase/7/docs/api/index.html?java/net/URL.html[java.net.URL]. +
Examples: PA:URL will accept "http://mysite.com" but not "c:/Temp".
* *PA:URI* : variable can be converted to https://docs.oracle.com/javase/7/docs/api/index.html?java/net/URI.html[java.net.URI]. +
Examples: PA:URI will accept "/tmp/file" but not "c:\a^~to" due to invalid characters.
* *PA:LIST(item1,item2,...)* : variable must be one of the values defined in the list. +
Examples: PA:LIST(a,b,c) will accept "a", "b", "c" but no other value.
* *PA:JSON* : variable syntax must be a valid JSON expression as defined in http://www.json.org/[JSON doc]. +
Examples: PA:JSON will accept {"name": "John", "city":"New York"} and empty values like {} or [{},{}], but not ["test" : 123] (Unexpected character ':') and {test : 123} (Unexpected character 't').
* *PA:REGEXP(pattern)* : variable syntax must match the regular expression defined in the pattern. The regular expression syntax is described in class https://docs.oracle.com/javase/7/docs/api/index.html?java/util/regex/Pattern.html[Pattern]. +
Examples: PA:REGEXP([a-z]+) will accept "abc", "foo", but not "Foo".

. Advanced variable models

* *PA:CATALOG_OBJECT* :
use this type when you want to reference and use, in the current workflow, another object from the Catalog. Various portals and tools will make it easy to manage catalog objects. For instance, at Job submission, you will be able to browse the Catalog to select the needed object. +
Variable value syntax must be a valid expression that matches the following pattern: `bucketName/objectName[/revision]`.
Note that the revision sub-pattern is a hash code number represented by 13 digit. +
Examples: PA:CATALOG_OBJECT accepts "bucket-example/object-example" and "bucket-example/object-example/1539310165443" but not "bucket-example/object-example/153931016" (invalid revision number) nor "bucket-example/" (missing object name).

* *PA:CATALOG_OBJECT(kind,contentType,bucketName,objectName)* :
One or more filters can be specified in the PA:CATALOG_OBJECT model to limit the accepted values. In that case, the variable value must be a catalog object which matches the `Kind`, `Content type`, `BucketName` and/or `ObjectName` requirements (For more information regarding Kind and Content type click <<_exportingimporting_objects_into_the_catalog, here>>). +
Note that Kind and Content type are case insensitive and require a "startsWith" matching, while BucketName and ObjectName are case sensitive and, by default, require a "contains" matching.
That is, the Kind and the Content type of the provided catalog object must start with the filters specified in the model while BucketName and ObjectName of the catalog object should contain them.
The scheduler server verifies that the object exists in the catalog and fulfills the specified requirements when the workflow is submitted. +
Examples:
** PA:CATALOG_OBJECT(Workflow/standard) accepts only standard workflow objects, that means PSA workflows or scripts are not valid values.
** PA:CATALOG_OBJECT(Script, text/x-python) accepts a catalog object which is a Python script but not a workflow object or a Groovy script.
** PA:CATALOG_OBJECT(,,basic-example, Native_Task) accepts catalog objects that are in buckets ia-basic-example or basic-example-python and named Native_Task or Native_Task_Python but not NATIVE_TASK. +

+
[none]
* Notice that the default behaviour of BucketName or ObjectName filters can be modified by including the special character `%` that matches any word.
Hence, by adding `%` in the beginning (resp. end) of a BucketName or an ObjectName we mean that the filtered value should end (resp. start) with the specified string. +
Examples:

[none]
* {empty}
[none]
** {empty}
*** PA:CATALOG_OBJECT(,,%basic-example) accepts catalog objects that are in buckets ia-basic-example or db-basic-example but not the ones in basic-example-python.
*** PA:CATALOG_OBJECT(,,,Native_Task%) accepts catalog objects that are named Native_Task or Native_Task_Python but not Simplified_Native_Task.
+
NOTE: It is possible to have a PA:CATALOG_OBJECT object variable that has an optional value by using the notation `PA:CATALOG_OBJECT?`. See <<optional_variable, here>>.

--
[none]
* {empty}

** *PA:CREDENTIAL* : variable whose value is a key of the <<_third_party_credentials, ProActive Scheduler Third-Party Credentials>> (which are stored on the server side in encrypted form). The variable allows the user to access a credential from the task implementation in a secure way (e.g., for a groovy task credentials.get(variables.get("MY_CRED_KEY")) instead of a plain-text. At workflow submission, the scheduler server verifies that the key exists in the 3rd party credentials of the user. In addition, the use of this model enables the user to manage her/his credentials via a graphical interface.
** *PA:CRON* : variable syntax must be a valid cron expression as defined in the  http://www.sauronsoftware.it/projects/cron4j/manual.php#p02[cron4j manual]. This model can be used for example to control the provided value to the `loop` control flow parameter.+
Examples: PA:CRON will accept "5 * * * \*" but not "* * * *" (missing minutes sub-pattern).
** *PA:DATETIME(format)* , *PA:DATETIME(format)[min,max]* : variable can be converted to a https://docs.oracle.com/javase/7/docs/api/index.html?java/util/Date.html[java.util.Date] using the format specified (see the format definition syntax in the https://docs.oracle.com/javase/7/docs/api/index.html?java/text/SimpleDateFormat.html[SimpleDateFormat] class). +
A range can also be used in the PA:DATETIME model. In that case, each bound of the range must match the date format used. +
This model is used for example to control an input value used to trigger the execution of a task at a specific date time.
+
Examples: +
PA:DATETIME(yyyy-MM-dd) will accept "2014-12-01" but not "2014". +
PA:DATETIME(yyyy-MM-dd)[2014-01-01, 2015-01-01] will accept "2014-12-01" but not "2015-03-01". +
PA:DATETIME(yyyy-MM-dd)[2014, 2015] will result in an error during the workflow definition as the range bounds [2014, 2015] are not using the format yyyy-MM-dd.
** *PA:MODEL_FROM_URL(url)* : variable syntax must match the model fetched from the given URL. This can be used for example when the model needs to represent a list of elements which may evolve over time and is updated inside a file. Such as a list of machines in an infrastructure, a list of users, etc. +
See <<_variable_model_using_resource_manager_data>> for premade models based on the Resource Manager state. +
Examples: PA:MODEL_FROM_URL(file:///srv/machines_list_model.txt), if the file machines_list_model.txt contains PA:LIST(host1,host2), will accept only "host1" and "host2", but may accept other values as the machines_list_model file changes.
** *PA:GLOBAL_FILE* : variable whose value is the relative path of a file in the <<_global_and_user_spaces, Global Data Space>>. At workflow submission, the scheduler server verifies that the file exists in the global dataspace. In addition, this model enables the user to graphically browse the global dataspace to select a file as an input data for the workflow.
** *PA:USER_FILE* : variable whose value is the relative path of a file in the <<_global_and_user_spaces, User Data Space>>. At workflow submission, the scheduler server verifies that the file exists in the user dataspace. In addition, this model enables the user to graphically browse the user dataspace to select a file as an input data for the workflow.
** *PA:GLOBAL_FOLDER* : variable whose value is the relative path of a folder in the <<_global_and_user_spaces, Global Data Space>>. At workflow submission, the scheduler server verifies that the folder exists in the global dataspace. Note, the variable value should not end with a slash to avoid the problem of duplicate slash in its usage.
** *PA:USER_FOLDER* : variable whose value is the relative path of a folder in the <<_global_and_user_spaces, User Data Space>>. At workflow submission, the scheduler server verifies that the folder exists in the user dataspace. Note, the variable value should not end with a slash to avoid the problem of duplicate slash in its usage.
** *PA:SPEL(SpEL expression)* : variable syntax will be evaluated by a https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html[SpEL] expression. Refer to the next paragraph.

--
====== Variable Model (Type) using a type defined dynamically in another Variable +

A Variable can use as its type a model that is defined in another variable. +

To use such possibility, the workflow designer can simply use in the Model definition of another specific variable name proceeded by the character `$`.

When submitting the workflow, the user will have the ability to select the model dynamically by changing the value of the referenced variable. And then will be able to select the value of the first variable according to the selected type. +

For example, if we have: +
`variable1` has as its model `PA:LIST(PA:GLOBAL_FILE, PA:INTEGER)` +
`variable2` has as its model `$variable1` +
Then the model of `variable2` is the value that the variable `variable1` will have in runtime. Thus, it will be either `PA:GLOBAL_FILE` or `PA:INTEGER`.

====== Optional Variable [[optional_variable]]

To define an *optional variable*, the workflow designer can simply add `?` at the end of the `model` attribute, such as `PA:INTEGER?`.

When submitting the workflow, it will be allowed to not provide a value for the optional variables.
The validation will only fail when the user fills in an invalid value.

For example, a variable `MY_OPTIONAL_INTEGER` defined as the model `PA:INTEGER?` will accept an empty string as the variable value, but it will refuse `1.4`.

All the available model syntaxes, except `PA:NOT_EMPTY_STRING` support to be defined as *optional*.

====== Variable Model using Resource Manager data

ProActive Resource Manager provides a set of REST endpoints which allow to create dynamic models based on the Resource Manager state.

These models are summarized in the following table. Models returned are PA:LIST types which allow to select a value in ProActive portals through a drop-down list.
The list always contain an empty value choice.

.Resource Manager Models
[%header,cols=4*]
|===
|Metric Name
|Description
|Model Syntax
|Example returned data

|Hosts
|All machine host names or ip addresses registered in the Resource Manager
|`PA:MODEL_FROM_URL(${PA_SCHEDULER_REST_PUBLIC_URL}/rm/model/hosts)`
|PA:LIST(,try.activeeon.com,10.0.0.19)

|Node Sources
|All node sources registered in the Resource Manager
|`PA:MODEL_FROM_URL(${PA_SCHEDULER_REST_PUBLIC_URL}/rm/model/nodesources)`
|PA:LIST(,Default,LocalNodes,GPU,Kubernetes)

|Tokens
|All tokens registered in the Resource Manager (across all registered ProActive Nodes). See <<_node_access_token>>.
|`PA:MODEL_FROM_URL(${PA_SCHEDULER_REST_PUBLIC_URL}/rm/model/tokens)`
|PA:LIST(,token1,token2)
|===

====== Spring Expression Language Model

The `PA:SPEL(expr)` model allows to define expressions able to validate a variable value or not. Additionally, this model can be used to validate multiple variable values or to dynamically update other variables.
The syntax of the SpEL expression is defined by the https://docs.spring.io/spring/docs/current/spring-framework-reference/html/expressions.html[Spring Expression Language reference]. +

For security concerns, we apply a restriction on the authorized class types. Besides the commonly used data types (Boolean, String, Long, Double, etc.), we authorize the use of *ImmutableSet*, *ImmutableMap*, *ImmutableList*, *Math*, *Date* types, *JSONParser* and *ObjectMapper* for `JSON` type and *DocumentBuilderFactory* for `XML` type.

In order to interact with variables, the expression has access to the following properties:

* `#value`: this property will contain the value of the current variable defined by the user.
* `variables['variable_name']`: this property array contains all the variable values of the same context (for example of the same task for a task variable).
* `models['variable_name']`: this property array contains all the variable models of the same context (for example of the same task for a task variables).
* `valid`: can be set to `true` or `false` to validate or invalidate a variable.
* `temp`: can be set to a temporary object used in the SpEL expression.
* `tempMap`: an empty Hash Map structure which can be populated and used in the SpEL expression.

The expression has also access to the following functions (in addition to the functions available by default in the SpEL language):

* `t(expression)`: evaluate the expression and return `true`.
* `f(expression)`: evaluate the expression and return `false`.
* `s(expression)`: evaluate the expression and return an empty string.
* `hideVar('variable name')`: hides the variable given in parameter. Used to build <<_dynamic_forms>>. Returns `true` to allow chaining actions.
* `showVar('variable name')`: shows the variable given in parameter. Used to build <<_dynamic_forms>>. Returns `true` to allow chaining actions.
* `hideGroup('group name')`: hides all variables belonging to the variable group given in parameter. Used to build <<_dynamic_forms>>. Returns `true` to allow chaining actions.
* `showGroup('group name')`: shows all variables belonging to the variable group given in parameter. Used to build <<_dynamic_forms>>. Returns `true` to allow chaining actions.

The SpEL expression must either:

* return a *boolean value*, `true` if the value is correct, `false` otherwise.
* set the *valid* property to `true` or `false`.

Any other behavior will raise an error.

* *Example of SpEL simple validations:* +
+
`PA:SPEL(#value == 'abc')` : will accept the value if it's the 'abc' string +
`PA:SPEL(T(Integer).parseInt(#value) > 10)` : will accept the value if it's an integer greater than 10. +
+
Note that #value always contains a string and must be converted to other types if needed. +
+
* *Example of SpEL multiple validations:* +
+
`PA:SPEL(variables['var1'] + variables['var2'] == 'abcdef')` : will be accepted if the string concatenation of variable var1 and var2 is 'abcdef'. +
`PA:SPEL(T(Integer).parseInt(variables['var1']) + T(Integer).parseInt(variables['var2']) < 100)` : will be accepted if the sum of variables var1 and var2 are smaller than 100. +
+
* *Example of SpEL variable inference:* +
+
`PA:SPEL( variables['var2'] == '' ? t(variables['var2'] = variables['var1']) : true )` : if the variable var2 is empty, it will use the value of variable var1 instead. +
+
+
* *Example of SpEL variable using ObjectMapper type:* +
+
`PA:SPEL( t(variables['var1'] = new org.codehaus.jackson.map.ObjectMapper().readTree('{"abc": "def"}').get('abc').getTextValue()) )` : will assign the value 'def' to the variable var1. +
+
+
* *Example of SpEL variable using DocumentBuilderFactory type:* +
+
`PA:SPEL( t(variables['var'] = T(javax.xml.parsers.DocumentBuilderFactory).newInstance().newDocumentBuilder().parse(new org.xml.sax.InputSource(new java.io.StringReader('<employee id="101"><name>toto</name><title>tata</title></employee>'))).getElementsByTagName('name').item(0).getTextContent()) )`: will assign the value 'toto' to the variable var1. +
+

NOTE: the SpEL expression must return a boolean value, this is why in the above expressions we use the `t(expression)` function to perform affectations and return a boolean `true` value.

[[_dynamic_forms]]
====== Dynamic form example using SpEL
Using SpEL expressions, it is possible to show or hide variables based on the values of other variables. Thus, it allows to create _dynamic forms_.

Consider the following variables definition (attributes xml escaping has been removed for clarity):

```xml
  <variables>
    <variable name="type" value="vegetable" model="PA:LIST(vegetable,fruit)" description="" group="" advanced="false" hidden="false"/>
    <variable name="potatoes" value="0" model="PA:INTEGER" description="Amount of potatoes to order (in kilograms)" group="vegetables" advanced="false" hidden="false"/>
    <variable name="leek" value="0" model="PA:INTEGER" description="Amount of leek to order (in kilograms)" group="vegetables" advanced="false" hidden="false"/>
    <variable name="apples" value="0" model="PA:INTEGER" description="Amount of apples to order (in kilograms)" group="fruits" advanced="false" hidden="true"/>
    <variable name="oranges" value="0" model="PA:INTEGER" description="Amount of oranges to order (in kilograms)" group="fruits" advanced="false" hidden="true"/>
    <variable name="type_handler" value="" model="PA:SPEL(variables['type'] == 'vegetable' ? showGroup('vegetables') && hideGroup('fruits') : showGroup('fruits') && hideGroup('vegetables'))" description="" group="" advanced="false" hidden="true"/>
  </variables>
```
The first variable `type` presents a choice to the user : select _fruits_ or _vegetables_.
The last variable `type_handler`, which is hidden to the user, analyses this choice and displays either variables belonging to the _fruits_ group or the _vegetables_ group.
The <<_spring_expression_language_model,SpEL>> model associated with `type_handler` performs this operation:

----
PA:SPEL(variables['type'] == 'vegetable' ? showGroup('vegetables') && hideGroup('fruits') : showGroup('fruits') && hideGroup('vegetables'))
----
When `type` is equal to `fruit`, then the variables belonging to the `vegetables` group are hidden, and the variables belonging to the `fruits` group are shown. Respectively, the `vegetables` group is shown and the `fruits` group is hidden when `type` is equal to `vegetable`.

The complete workflow example can be downloaded link:examples/my_basket.xml[here^].

Here is how the variables are displayed when submitting the workflow:

image:vegetables.png[Vegetables, align="center"]

image:fruits.png[Fruits, align="center"]



[[_dynamic_variables]]
==== Dynamic Variables

As opposed to <<_workflow_variables>>, *dynamic variables* are created or manipulated directly when executing workflow tasks scripts,
through the use of the `variables` script binding map (see the <<../user/ProActiveUserGuide.adoc#_script_bindings,Script Bindings chapter>> or <<_variables_quick_reference,Script Bindings Reference>> for more information about script bindings).
We have mainly two types of *dynamic variables*:

- <<_system_variables>>, declared by the ProActive scheduler.
- <<_inherited_variables>>, created after adding values to the `variables` map.

[[_system_variables]]
===== ProActive system variables

Some variables are implicitly defined by the Scheduler to retrieve runtime information about a job or a task.

Here is the list of ProActive system variables:

.ProActive variables
[cols="2,5,2"]
|===
| *Variable name* |Â *Description* | *Type*
| `PA_JOB_ID`
| The current job ID.
| String

| `PA_JOB_NAME`
| The current job name.
| String

| `PA_TASK_ID`
| The current task ID.
| String

| `PA_TASK_NAME`
| The current task name.
| String

| `PA_TASK_ITERATION`
| The current iteration index, when using <<_loop,looping>>, starts at 0.
| Integer

| `PA_TASK_REPLICATION`
| The current iteration index, when using a <<_replicate,replication>>, starts at 0.
| Integer

| `PA_TASK_PROGRESS_FILE`
| The path to the progress file, used to set the task's progress.

  You can import and use the utility class `org.ow2.proactive.scripting.helper.progress.ProgressFile` to read/write values to the file identified by this variable.
| String

| `PA_SCHEDULER_HOME`
| The path to Scheduler home, where the Scheduler or the Node is installed.
| String

| `PA_NODESFILE`
| The path to the hostfile when using a <<_multi_node_task,multi nodes task>>.
| String

| `PA_NODESNUMBER`
| The number of acquired nodes when using a <<_multi_node_task,multi nodes task>>.
| Integer

| `PA_USER`
| The username of the ProActive user who has submitted the job.
| String

| `PA_SCHEDULER_REST_URL`
| The URL of scheduler REST api.
| String

| `PA_SCHEDULER_REST_PUBLIC_URL`
| The URL of scheduler REST public api if the setting pa.scheduler.rest.public.url is defined in `PROACTIVE_HOME/config/scheduler/settings.ini`.
| String

| `PA_CATALOG_REST_URL`
| The URL of catalog REST api.
| String

| `PA_CATALOG_REST_PUBLIC_URL`
| The URL of catalog REST public api if the setting pa.catalog.rest.public.url is defined in `PROACTIVE_HOME/config/scheduler/settings.ini`.
| String

| `PA_CLOUD_AUTOMATION_REST_URL`
| The URL of Service Automation REST api.
| String

| `PA_CLOUD_AUTOMATION_REST_PUBLIC_URL`
| The URL of Service Automation REST public api if the setting pa.cloud-automation.rest.public.url is defined in `PROACTIVE_HOME/config/scheduler/settings.ini`.
| String

| `PA_JOB_PLANNER_REST_URL`
| The URL of job planner REST api.
| String

| `PA_JOB_PLANNER_REST_PUBLIC_URL`
| The URL of job planner REST public api if the setting pa.job-planner.rest.public.url is defined in `PROACTIVE_HOME/config/scheduler/settings.ini`.
| String

| `PA_NOTIFICATION_SERVICE_REST_URL`
| The URL of notification service REST api.
| String

| `PA_NOTIFICATION_SERVICE_REST_PUBLIC_URL`
| The URL of notification service REST public api if the setting pa.notification-service.rest.public.url is defined in `PROACTIVE_HOME/config/scheduler/settings.ini`.
| String

|===

They can be used inside the workflow with the pattern syntax, for example:

[source, xml]
----
<task ...>
    ...
     <forkEnvironment workingDir="/opt/${PA_JOB_ID}"></forkEnvironment>
    ...
</task>
----

[[_inherited_variables]]
===== Script variables

In addition to the ability to declare variables directly inside job XML definition, it is also possible to
dynamically read and write new variables while executing a task script with the `variables` map. This map of `variables` is bound to
hash type depending on the script engine you are using, for instance in native
Java as https://docs.oracle.com/javase/8/docs/api/java/util/Map.html[Map^].
In *Groovy*  as a global map, see below:

[source, groovy]
----
String var = variables.get("one_variable")
variables.put("other_variable", "foo")
----

In the *Groovy* example above the first line retrieve the value of variable
`one_variable` from the `variables` map. The second line create a new entry  `other_variable` with value `foo`.
The `variables` map is propagated down the execution chain. If a task modifies a variable in the variables map,
or add a new variable, all dependent tasks will have access to this modification.
For example:

[source, groovy]
----
// task1
String var = variables.get("one_variable")
variables.put("one_variable", "foo")
variables.put("other_variable", "bar")
----

[source, groovy]
----
// task2 depends on task1
println variables.get("one_variable") // will display "foo"
println variables.get("other_variable") // will display "bar"
----

If a task depends on several tasks and each task modifies the same variable, the final value of the variable
which is propagated down the execution chain, depends on the *order of task execution*.
Therefore, the users need to take appropriate measures to prevent any undesired effects such as race conditions.

System variables can also be accessed from the `variables` map, for example:

[source, groovy]
----
println variables.get("PA_JOB_ID") // will display the id of the current job
----

If using a *Bash shell script*, variables are accessible through environment variables.

[source, bash]
----
#!/bin/bash
echo $variables_PA_TASK_NAME
----

WARNING: In native tasks and Bash/CMD script engines, variables can be read but not written to.



For Java native script you can set any link:https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[Java serializable object, window="_blank"]
 as a variable value. They will be converted into strings using
https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()[toString()^]
 method when required, for instance, to make those values available as environment variables in native tasks.


The field variable tag has an `inherited` field, if this field is set as true a task variable will read
its value from the *variables* map instead of the `value` field in the XML definition.
In this case, the *value* field becomes optional and work as a default value.
Below a XML schema that shows two tasks: *first* and *second*. Task *first* insert a new
variable using `variables.put("inherited_var", "somevalue")`.
Task *second* declares *inherited_var*
but with *defaultvalue*, this value will be overwritten by the  *first* task, `variables.put("inherited_var", "somevalue")`.
Defining a default value  might be useful if for some reason the *first* task fails before inserting the *inherited_var*
on *variables* map. In this last case the `defaultvalue` remains unchanged.



[source, xml]
----
<task name="first" >
    <scriptExecutable>
        <script>
            <code language="groovy">
                <![CDATA[
                variables.put("inherited_var", "somevalue")
                ]]>
            </code>
        </script>
    </scriptExecutable>
</task>
...
<task name="second">
    <variables>
        <variable name="inherited_var" value="defaultvalue" inherited="true"/>
    </variables>
    <depends>
        <task ref="before"/>
    </depends>
...
</task>
----


===== Dynamic replacements

We've seen in <<_job_variables>> that we can use the `${varname}` syntax to create and access variables.
Dynamic replacement is in charge to resolve variables just before the execution of task script, or
in case of job variables, just before submitting the job.
We can also combine recursive definitions of variables.

For example, one could write:
[source, xml]
----
<job ...>
    ...
    <variables>
        <variable name="job_var" value="hello" model=""/>
        <variable name="job_var2" value="${job_var}" model=""/>
        <variable name="job_var3" value="${job_var2}" model=""/>
    </variables>
    ...
</job>
----

The dynamic replacement will resolve `job_var3` to `hello` just before submitting the job to the scheduler.

WARNING:  We can use job variable references in task variables but not otherwise.


When dynamic replacing a task script variable the resolution happens just before running the task. So we can
 use the `variables` map value. The example below will print "hello world" because `hello` is recursively
 resolved at job level assigning `hello world` to `inherited_var`. When `task_2` starts its local
    variable `task_var2` is dynamically replaced by `hello world`, i.e., the content of `inherited_var` that was
    inserted in the `variables` map by the previous task.


[source, xml]
----
<job ... >
  <variables>
    <variable name="job_var" value="hello" model=""/>
    <variable name="job_var2" value="${job_var}" model=""/>
  </variables>
  <taskFlow>
    <task name="task_1" >
      <scriptExecutable>
        <script>
          <code language="groovy">
            <![CDATA[
            variables.put("inherited_var", "\${job_var2} world")
            ]]>
          </code>
        </script>
      </scriptExecutable>
    </task>
    <task name="task_2">
      <variables>
        <variable name="task_var2" value="${inherited_var}" inherited="false"/>
      </variables>
      <depends>
        <task ref="task_1"/>
      </depends>
      <scriptExecutable>
        <script>
          <code language="groovy">
            <![CDATA[
            println ""+variables.get("task_var2")
            ]]>
          </code>
        </script>
      </scriptExecutable>
    </task>
  </taskFlow>
</job>
----



Note that we can combine recursive definitions of variables.

For example, one could write:

[source, xml]
----
<task ...>
    ...
     <forkEnvironment workingDir="/opt/${DIRECTORY_${PA_TASK_REPLICATION}}"></forkEnvironment>
    ...
</task>
----

In that case, the variable `DIRECTORY_0` or `DIRECTORY_1`, etc (depending on the replication index) will be used in the working dir attribute.

Pattern variable replacements may be performed at submission time or at execution time:

- A replacement performed at *execution time* means that the replacement is executed only when the task enclosing the replacement is executed.
- A replacement performed at *submission time* means that the replacement is directly executed when the job is submitted to the scheduler.

Replacements directly using global job or task variables will always be performed at submission time.

In the following example, the description replacement is performed at submission time:

[source, xml]
----
<job ... >
    <variables>
        <variable name="description" value="My ProActive workflow"/>
    </variables>
    ...
    <task ... >
        <description>${description}</description>

    </task>
</job>
----

Replacements using system variables, such as the workingDir example above, will always be performed at execution time.




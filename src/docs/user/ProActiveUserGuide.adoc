:docinfo:
= ProActive Workflows & Scheduling
include::../common-settings.adoc[]
:toc-title: User Guide

== Overview

include::../Overview.adoc[]

=== Glossary

include::../Glossary.adoc[]

== Get started

To submit your first computation to *ProActive Scheduler*, link:../admin/ProActiveAdminGuide.html#_getting_started[install] it in
your environment (default credentials: admin/admin) or just use our demo platform http://try.activeeon.com[try.activeeon.com^].

*ProActive Scheduler* provides comprehensive interfaces that allow to:

- http://try.activeeon.com/studio[Create workflows^]
- http://try.activeeon.com/scheduler[Submit workflows, monitor their execution and retrieve the tasks results^]
- http://try.activeeon.com/rm[Add resources and monitor them^]

We also provide REST and command line interfaces for advanced users.

== Create and run your computation

=== Jobs, workflows and tasks

In order to use Scheduler for executing various computations, one needs to write the execution definition
also known as the Workflow definition. A workflow definition is an XML file that adheres to
<<_job_and_task_specification,XML schema for ProActive Workflows>>.

It specifies a number of XML tags for specifying execution steps, their sequence and dependencies.
Each execution step corresponds to a task which is the smallest unit of execution that can be performed on a
 computation resources. There are several types of tasks which caters different use cases.

*ProActive Scheduler* currently supports three main types of tasks:

- *Native Task*, an executable with eventual parameters to be executed
- *Script Task*, a script written in Groovy, Ruby, Python and other languages supported by the JSR-223
- *Java Task*, a task written in Java extending the Scheduler API

WARNING: We strongly recommend to use script tasks that are more flexible rather than Java tasks.
You can easily integrate with any Java code from a Groovy script task.
In the near future, *Java tasks might be removed*.

For instance, a script
task can be used to execute an inline script definition or a script file as an execution step whereas a
native task can be used to execute a native executable file.

One can use **ProActive Workflow Studio**  to create and submit workflows graphically .
You can simply drag-and-drop various task constructs and draw their dependencies to form complex jobs.
It also provides various flow control widgets such as conditional branch, loop, replicate etc to construct complex workflows.

image::flow_spec_dependency.png[align="center"]

In this tasks graph, we see that task 4 is preceded by task 1, that
means the Scheduler waits the end of task 1 execution before launching task
4. In a more concrete way, task 1 could be the calculation of a part of
the problem to solve, and task 4 takes the result provided by task 1 and
compute another step of the calculation. We introduce here the concept
of <<_passing_data_between_tasks,result passing>> between tasks. This relation is
called a <<_dependency>>, and we say that task 4 **depends** on task 1.

We see that task 1, 2 and 3 are not linked, so these three tasks can be
executed in **parallel**, because there are independent from each other.

The task graph is defined by the user at the time of workflow creation, but can also be modified during
 the job execution by control flow actions such as <<_replicate>>.

A *finished job* contains the results and logs of each task. Upon failure,
a task can be restarted automatically or cancelled.

=== A simple example

The link:http://try.activeeon.com/tutorials/quickstart/quickstart.html[quickstart tutorial, window="_blank"] on link:http://try.activeeon.com[try.activeeon.com, window="_blank"]
shows you how to build a simple workflow using script tasks.


=== Docker task

In order for Docker tasks to work, the _Node_ must have Docker and Docker Compose installed, please refer to the official
 Docker documentation to see how to install http://docs.docker.com/engine/installation/[Docker^] and https://docs.docker.com/compose/install/[Docker Compose^].

A Docker task expects the content of a Docker Compose file inside the _Script_ section. You can find out how to write Docker Compose files
with the official https://docs.docker.com/compose/[Docker Compose documentation^].

To get started: a simple Docker Compose example is explained below.

The content of the _Script_ section (equal to the content of a Docker Compose file) is:
---
helloworld:
    image: busybox
    command: echo "Hello ProActive"
---
The above example describes a container which is called 'helloworld'. That container is created from a busybox image,
 which will run the command 'echo "Hello ProActive"'


=== Native application

Using native tasks you can easily reuse existing applications and embed them in a workflow.
The Scheduler lets you define a native task that takes the name of the executable and list of parameters.
Once the executable is wrapped as a task you can easily leverage some of the workflow constructs to run your
executable in parallel.

TIP:  We advise you to test your application first, make sure that it works with a simple use case on
one machine and then embed it in a workflow.

You can find an example of such integration in this
link:examples/native_task.xml[XML workflow^] or you can also build one yourself using the
*Workflow Studio*.

Native application by nature can be tied to a given operating system so
if you have different nodes at your disposal, you might need to select a suitable node to run your native task.
This can be achieved using <<_selection,selection script>>.

=== Scripting language support

Proactive Scheduler supports tasks  written in languages other than Java. The currently supported dynamic languages are
link:http://groovy.codehaus.org[Groovy, window="_blank"],
link:http://www.jython.org[Python, window="_blank"],
link:http://jruby.org[Ruby, window="_blank"] and
link:http://docs.oracle.com/javase/6/docs/technotes/guides/scripting/programmer_guide/#jsengine[Javascript, window="_blank"].

Native scripts can also be executed using a script task. Currently Bash and CMD scripts are supported,
simply set the language attribute to `bash` or `cmd` and type your script in the workflow.

You can easily embed small scripts in your workflow.
The nice thing is that the workflow will be self-contained and will not require to compile your code before executing. However, we
recommend that you keep these scripts smalls to keep the workflow easy to understand.

TIP: Use scripts to print debugging statements when you build a new workflow.

Please note that the script execution relies on Java implementation of the cited languages thus it may come with
some limitations.

You can find an example of a script task in this
link:examples/script_task.xml[XML workflow^] or you can also build one yourself using the
*Workflow Studio*. The link:http://try.activeeon.com/tutorials/quickstart/quickstart.html[quickstart tutorial, window="_blank"]
relies on script task and is a nice introduction to workflows.

Scripts can also be used to decorate tasks with specific actions, we support
<<_pre_post_clean,pre>>, <<_pre_post_clean,post>>, <<_pre_post_clean,clean>> and <<_selection,selection>> scripts.

=== MPI application

http://en.wikipedia.org/wiki/Message_Passing_Interface[MPI^] is often used in the area of parallel computing.
The Scheduler integrates with MPI with the concept of <<_multi_node_task,multi node tasks>>.
 This particular task will acquire several nodes and will expose these nodes to the MPI environment.

Applications built with MPI are often executed using the http://linux.die.net/man/1/mpirun[mpirun^] command.
It accepts several parameters to
choose how many CPUs and how many machines will be used. One particular parameter is the machine file that is
built by the Scheduler when using *multi node tasks*.
Here is how an MPI application invocation would look like when executed with the Scheduler:

    mpirun -hostfile $variables_PA_NODESFILE myApplication

The <<_workflow_variables,variable>> `$variables_PA_NODESFILE` contains the path to a machine file created by the Scheduler that will be similar to:

    compute-host
    compute-host
    another-host

Meaning that `myApplication` will use 2 CPUs on `compute-host` and 1 CPU on `another-host`.
You can also use `$variables_PA_NODESNUMBER` to retrieve the number of acquired nodes.

You can find an example of a native task in this
link:examples/mpi_task.xml[XML workflow^] or you can also build one yourself using the
*Workflow Studio*.

To achieve the best performance for MPI applications, nodes can be selected taking into account their *network topology*. One might want to select nodes that are as
close to each other as possible to obtain better network performance or nodes on different hosts to split the I/O load.
Refer to <<_topology_types>> for more details.

=== Run a workflow

To run a workflow, the user submits it to *ProActive Scheduler*.
A verification is performed to ensure the well-formedness of the workflow.
Next, a job is created and inserted into the pending queue and
waits until free resources become available.
Once the required resources are provided by the ProActive Resource Manager, the job is started. Finally,
once the job is finished, it goes to the queue of finished
jobs where its result can be retrieved.

You can submit a workflow to the Scheduler using the *Workflow Studio*, the Scheduler Web Interface or <<_scheduler_command_line,command
line tools>>. For advanced users we also expose REST and JAVA APIs.

TIP: During the submission, you will be able to edit <<_workflow_variables>>, so you can effectively use
them to parameterize workflow execution and use workflows as <<_templating,templates>>.

==== Job & Task states

During their execution, jobs and tasks go through different states:

.Job States
[cols="17%,17%,66%", options="header"]
|===
| State | Name | Description
| `CANCELED` | Cancelled | The job has been canceled because of an exception.
This status is used when an exception is thrown by the user code of a task and when the user has asked to cancel the job on exception.
| `FAILED` | Failed | The job has failed. One or more tasks have failed (due to resources failure).
There is no more executionOnFailure left for a task.
| `FINISHED` | Finished | The job is finished. Tasks are finished or faulty.
| `IN_ERROR` | In-Error | The job has at least one In-Error task and all In-Error tasks are the last, among others, which have changed their state.
| `KILLED` | Killed | The job has been killed by the user.
| `PAUSED` | Paused | The job is paused waiting for user to resume it.
| `PENDING` | Pending | The job is waiting to be scheduled.
| `RUNNING` | Running | The job is running. At least one of its task has been scheduled.
| `STALLED` | Stalled | The job has been launched but no task is currently running.

|===


.Task States
[cols="17%,17%,66%", options="header"]
|===
| State | Name | Description |
 `ABORTED` | Aborted | The task has been aborted by an exception on an other task while the task is running. (job is cancelOnError=true).
 Can be also in this status if the job is killed while the concerned task was running. |
 `FAILED` | Resource down | The task is failed
(only if maximum number of execution has been reached and the node on which it was started is down).|
 `FAULTY` | Faulty | The task has finished execution with error code (!=0) or exception. |
 `FINISHED` | Finished | The task has finished execution. |
 `IN_ERROR` | In-Error | The task is suspended after first error, if the user has asked to suspend it. The task is waiting for a manual restart action. |
 `NOT_RESTARTED` | Could not restart | The task could not be restarted.
  It means that the task could not be restarted after an error
  during the previous execution. |
 `NOT_STARTED` | Could not start | The task could not be started.
  It means that the task could not be started due to
   dependencies failure.|
 `PAUSED` | Paused | The task is paused.|
 `PENDING` | Pending | The task is in the scheduler pending queue.|
 `RUNNING` | Running | The task is executing.|
 `SKIPPED` | Skipped | The task was not executed: it was the non-selected branch of an IF/ELSE control flow action. |
 `SUBMITTED` | Submitted | The task has just been submitted by the user.|
 `WAITING_ON_ERROR` | Faulty... | The task is waiting for restart after an error (i.e. native code != 0 or exception, and maximum number of execution is not reached).|
 `WAITING_ON_FAILURE` | Failed... | The task is waiting for restart after a failure (i.e. node down). |

|===

// TODO state diagram

==== Retrieve results

Once a job or a task is terminated, it is possible to get its result. You can only get the result of the job that you own.
Results can be retrieved using the Scheduler Web Interface or the command line tools.

Along with results you can also retrieve logs of the tasks (standard ouput and error output)
as well as Scheduler logs that provide debugging information.

NOTE: When running native application, the task result will be the exit code of the application. Results
usually make more sense when using script or Java tasks.

==== Job Priority

A job is assigned a default priority of `NORMAL` but the user can increase or decrease the priority once the
job has been submitted. When they are scheduled, jobs with the highest priory are executed first.

The following values are available:

- `IDLE`
- `LOWEST`
- `LOW`
- `NORMAL`
- `HIGH` can only be set by an administrator
- `HIGHEST` can only be set by an administrator

== Data Management

One of the major questions after having learned to submit and execute simple tasks is how to handle data.

ProActive Scheduler provides two mechanisms for accessing and propagating data down the execution chain. One is based on <<_variable_based_propagation,variables>> and the other on <<_file_based_propagation,files>>.

=== Variable based propagation

Variables used for data access and propagation exist in three flavors:

- <<_workflow_variables,Workflow variables>>
- <<_proactive_system_variables,ProActive system variables>>
- <<_generic_information>>
- <<_passing_data_between_tasks_using_variables,Script variables>>

Their usage depends of the context (see <<_variables_quick_reference>>).

==== Workflow variables

In a workflow you can define *variables* that are available in all tasks.

[source, xml]
----
<variables>
    <variable name="variable" value="value"/>
</variables>
----

Then, anywhere in your task you can reference to it. For example in a *Groovy* script task, you can use:

[source, groovy]
----
String var = variables.get("variable")
variables.put("other_variable", "foo")
----

Inside a script, `variables` is bound to a http://docs.oracle.com/javase/8/docs/api/java/util/Map.html[Map^].
The syntax to access it might differ given the script engine you are using.

But you can also refer to a variable from the workflow definition itself, for instance:

[source, xml]
----
<nativeExecutable>
    <staticCommand value="${variable}" />
</nativeExecutable>
----

Inside a workflow you can use the `${VARIABLE_NAME}` syntax to access it (variable names are case-sensitive).
Most of the time, variable replacements are performed at runtime.
However, some of the information in the XML need to be processed at submission time and variable replacements might
be performed at that moment (for instance job name, task attributes, etc.).

[[_templating]]
Variables are very useful to use workflows as templates where only a few parameters change for each
execution. Upon submission you can define variable values either from <<_scheduler_command_line, CLI>> or from
the Web interfaces.

From a native executable, for instance a Shell script, variables are accessible through environment variables.

[source, bash]
----
#!/bin/bash
echo $variables_PA_TASK_NAME
----

WARNING: In native tasks and Bash/CMD script engines, variables can be read but not written to.

If a task depends on several tasks and each task modifies the same variable, the final value of the variable
which is propagated down the execution chain, depends on the *order of task execution*.
Therefore, the users need to take appropriate measures to prevent any undesired effects of such race conditions.

You can set any link:http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html[Java serializable object, window="_blank"]
 as a variable value. They will be converted into strings using
http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString()[toString()^]
 method when required, for instance, to make those values available as environment variables in native tasks.


==== ProActive system variables

Some variables are explicitly defined by the Scheduler to retrieve runtime information about a job or a task.
You can retrieve them through the `variables` map or the `${}` syntax in the workflow XML definition depending of the context.

[source, groovy]
.Example for retrieving the task ID from a Groovy script
----
String taskId = variables.get("PA_TASK_ID")
----

Here the list of ProActive system variables:

.ProActive variables
[cols="2,5,2"]
|===
| *Variable name* | *Description* | *Type*
| `PA_JOB_ID`
| The current job ID.
| String

| `PA_JOB_NAME`
| The current job name.
| String

| `PA_TASK_ID`
| The current task ID.
| String

| `PA_TASK_NAME`
| The current task name.
| String

| `PA_TASK_ITERATION`
| The current iteration index, when using <<_loop,looping>>, starts at 0.
| Integer

| `PA_TASK_REPLICATION`
| The current iteration index, when using a <<_replicate,replication>>, starts at 0.
| Integer

| `PA_TASK_PROGRESS_FILE`
| The path to the progress file, used to set the task's progress.

  You can import and use the utility class `org.ow2.proactive.scripting.helper.progress.ProgressFile` to read/write values to the file identified by this variable.
| String

| `PA_SCHEDULER_HOME`
| The path to Scheduler home, where the Scheduler or the Node is installed.
| String

| `PA_NODESFILE`
| The path to the hostfile when using a <<_multi_node_task,multi nodes task>>.
| String

| `PA_NODESNUMBER`
| The number of acquired nodes when using a <<_multi_node_task,multi nodes task>>.
| Integer

| `PA_USER`
| The username of the ProActive user who has submitted the job.
| String

|===

==== Generic Information

In addition to variables, another key/value structure can be accessed inside a script: *_Generic Information_*.

Generic information semantics differ from <<_workflow_variables>> semantics in the following way:

 * Generic information can be accessed inside a script, but cannot be modified.
 * Generic information can be defined at *job level* or at *task level*. If the same generic information is defined at job level and at task level, the latter value takes precedence inside the task scope.
 * Generic information cannot be used directly inside the workflow with the syntax ${} (See  <<_workflow_variables>>).
 * Generic information are used in general internally by the scheduler, for example to provide information to the scheduling loop on how to handle the task. An example of such generic information is the _START_AT_ info used inside <<_cron_tasks>>.

==== Passing data between tasks using variables

Another important mechanism of data exchange is the task *result* variable. Anywhere in a task (usually at the end) you can set a value to a reserved
variable named *result* using any Java object. This value will be available in tasks depending on it. Moreover, in case of several dependencies,
results will be aggregated into a new array variable named *results*.

Assumming that we have two tasks *task1* and *task2* written in Groovy:

[source, groovy]
----
// task1
result = "task1";
----

[source, groovy]
----
// task2
result = "task2";
----

and *task3* that depends on tasks *task1* and *task2*, then, you can access result values defined by the parents as follows:

[source, groovy]
----
// task3
println(results[0]);
// will print "task1"
println(results[1]);
// will print "task2"
----

NOTE: results will be aggregated according to the order declared in the dependency list. Consequently, if the xml *depends* tag of *task3* contains the list [task1, task2] (see the xml example below), then results[0] will contain the result of *task1* and results[1] the result of *task2*. On the contrary, if the depends list is [task2, task1], then results[0] will contain the result of *task2* and results[1] the result of *task1*.

[source, xml]
----
<depends>
        <task ref="task1"/>
        <task ref="task2"/>
</depends>
----

=== File based propagation

==== Input/Output Data in Shared Directory

The easiest way to use your data on computing machines is to set up a *shared directory* available on all Compute Hosts. For
Linux it's typically an NFS directory, for Windows it could be an SMB network share. Then, in tasks you can manipulate
files seamlessly across ProActive Nodes.

[source, java]
----
File inputData = new File("/data/username/inputfile");
----

This approach has some limitations though:

* The path to the shared folder should be *identical* on all Compute Hosts
* It can be difficult to use with *heterogeneous resources*, e.g. Linux and Windows hosts

==== Data Spaces

===== Global and User Spaces

If a shared folder is not an option in your environment, the ProActive Scheduler provides a convenient way to access
your data. It has two types of storage on the host where the server is running:

* A *Global Space* where anyone can read/write files
* An *User Space* which is a personal user data storage

By default, these spaces are linked to folders in the *data* directory of the ProActive Scheduler host:

 * `PROACTIVE_HOME/data/defaultglobal`
 * `PROACTIVE_HOME/data/defaultuser`

But it can be changed in `PROACTIVE_HOME/config/scheduler/settings.ini`.

===== Local Space

All files that are stored in these spaces can be read from all computing nodes. However, data transfer is declarative and not explicit.
You need to define which files have to be transferred from a data space to computing nodes by using *input files* and reciprocally from computing nodes to a data space by defining *output files*:

[source, xml]
----
<task name="task1">
    ...
    <inputFiles>
        <files includes="tata" accessMode="transferFromGlobalSpace"/>
    </inputFiles>
    <outputFiles>
        <files includes="titi*" accessMode="transferToGlobalSpace"/>
    </outputFiles>
    ...
</task>
----

Upon the execution of the previous example, Proactive Scheduler automatically transfers all files to a ProActive Node where the task will be executed. The files are put in a special place called *Local Space* on the ProActive Node. It corresponds to the working directory of a task when the task is in fork mode (default).
From a task point of view, files can be accessed normally like shown below:

[source, java]
----
File inputFile = new File("tata")
----

Then, based on the previous task definition, all the files whose the name starts with _titi_ (e.g titi, titi2, etc.) produced by _task1_ will be transferred back automatically to Global Space by the Scheduler once the task is finished.

Files can be also transferred from/to User Space by specifying `transferFromUserSpace`/`transferToUserSpace`.

Before running your jobs you should first *upload* your files into either Global or User Space. To do it you can export folders linked to
these spaces by one of the standard protocols like *FTP*, *NFS*, or use available web interfaces like
http://pyd.io[Pydio^].

It is possible to use wildcards in transfer directives, such as:

[source, xml]
----
<task name="task1">
    ...
    <inputFiles>
        <files includes="**/tata" accessMode="transferFromGlobalSpace"/>
    </inputFiles>
    <outputFiles>
        <files includes="*" accessMode="transferToGlobalSpace"/>
    </outputFiles>
    ...
</task>
----

More information of pattern syntax can be found in the https://docs.oracle.com/javase/7/docs/api/java/nio/file/FileSystem.html#getPathMatcher(java.lang.String)[FileSystem class JDK documentation].


===== Cache Space

In addition to transferring to the Task *Local Space*, it is also possible to transfer files to the Node host *Cache Space*.

From the Node host point of view, the Cache Space is *unique* and shared for all tasks and all ProActive Nodes deployed on the host.

Transfers to the cache are *not concurrent*, only a single task can transfer to the cache at the same time. I.e if multiple tasks are run in parallel on the same hosts and they all transfer to the cache, these transfers will be executed sequentially.

If a file declared for the transfer is newer than the existing version in the cache, the file will be updated.

In order to transfer files to the cache, simply use the cache transfer directives inside your job:

[source, xml]
----
<task name="task1">
    ...
    <inputFiles>
        <files includes="tata" accessMode="cacheFromGlobalSpace"/>
        <files includes="toto" accessMode="cacheFromUserSpace"/>
    </inputFiles>
    ...
</task>
----

The files will not be transferred to the Local Space of the task, so it will not be possible to access these files from the current directory.

In order to access these files, use the *cachespace* variable which contains the location of the cache, for example in groovy:

[source, groovy]
----
inputFile = new File(cachespace, "tata")
----

There are no transfer directives to transfer output files *from* the cache. Output files transfers are only possible from the *Local Space*.

Files in the cache space are *automatically deleted* after a given period. The default invalidation period is two weeks, which means that files older than two weeks will be automatically deleted.

In order to change this period, the ProActive Node must be started with the property *node.dataspace.cache.invalidation.period* (in miliseconds).

The property *node.dataspace.cachedir* can also be used to control the cache location on the node.

=== Job Result

Once a Job is terminated, it is possible to get its result. You can only get the result of the job that you own.
A Job result is the collection of the tasks' results and you can retrieve it from either Java API or <<_scheduler_command_line,command line>> (it will be converted to a string).

Job results are also available in the *Scheduler Web Interface* in the _Preview_ tab.

== Workflow concepts

Workflows comes with constructs that help you distribute your computation. The tutorial
http://try.activeeon.com/tutorials/adv.html[Advanced workflows^] is a nice introduction to workflows with
ProActive.

The following constructs are available:

- *Dependency*
- *Replicate*
- *Branch*
- *Loop*

TIP: Use the *Workflow Studio* to create complex workflows, it is much easier than writing XML!

=== Dependency

Dependencies can be set between tasks in a TaskFlow job. It provides a way to execute your tasks in a specified order,
but also to forward result of an ancestor task to its children as parameter. Dependency between tasks is then
both a temporal dependency and a data dependency.

image::flow_spec_dependency.png[align="center"]

Dependencies between tasks can be added either in *ProActive Workflow Studio* or simply in workflow XML as shown below:

[source, xml]
----
<taskFlow>
    <task name="task1">
        <scriptExecutable>
            <script>
                <code language="groovy">
                    println "Executed first"
                </code>
            </script>
        </scriptExecutable>
    </task>
    <task name="task2">
        <depends>
            <task ref="task1"/>
        </depends>
        <scriptExecutable>
            <script>
                <code language="groovy">
                    println "Now it's my turn"
                </code>
            </script>
        </scriptExecutable>
    </task>
</taskFlow>
----

[[_replicate]]
=== Replicate

The *replication* allows the execution of multiple tasks in parallel when only one task
is defined and the number of tasks to run could change.

image::flow_spec_duplicate.png[align=center]

-   The target is the direct child of the task initiator.

-   The initiator can have multiple children; each child is replicated.

-   If the target is a *start block*, the whole block is replicated.

-   The target must have the initiator as only dependency: the action is
    performed when the initiator task terminates. If the target has an
    other pending task as dependency, the behaviour cannot be specified.

-   There should always be a merge task after the target of a replicate:
    if the target is not a start block, it should have at least one
    child, if the target is a start block, the corresponding end block
    should have at least one child.

-   The last task of a replicated task block (or the replicated task if
    there is no block) cannot perform a *branching* or *replicate*
    action.

-   The target of a *replicate* action can not be tagged as *end block*.

- The current replication index (from to 0 to `runs`) can be accessed via the
`PA_TASK_REPLICATION` <<_workflow_variables,variable>>.

TIP: If you are familiar with programming, you can see the replication as forking tasks.

=== Branch

The *branch* construct provides the ability to choose between two alternative task flows,
with the possibility to merge back to a common flow.

image::flow_spec_if.png[align=center]

-   There is no explicit dependency between the initiator and the
    *if/else* targets. These are *optional links* (ie. A -> B or E ->
    F) defined in the *if* task.

-   The *if* and *else* flows can be merged by a *continuation* task
    referenced in the *if* task, playing the role of an *endif*
    construct. After the branching task, the flow will either be that of
    the *if* or the *else* task, but it will be continued by the
    *continuation* task.

-   *If* and *else* targets are executed *exclusively*. The initiator
    however can be the dependency of other tasks, which will be executed
    normally along the *if* or the *else* target.

-   A *task block* can be defined across *if*, *else* and *continuation*
    links, and not just plain dependencies (i.e. with *A* as *start* and
    *F* as *end*).

-   If using no continuation task, the if and else targets, along with
    their children, must be strictly distinct.

-   If using a continuation task, the if and else targets must be
    strictly distinct and valid task blocks.

-   *if*, *else* and *continuation* tasks (B, D and F) cannot have
    an explicit dependency.

-   *if*, *else* and *continuation* tasks cannot be entry points for the
    job, they must be triggered by the *if* control flow action.

-   A task can be target of only one *if* or *else* action. A
    *continuation* task can not merge two different *if* actions.

TIP: If you are familiar with programming, you can see the branch as a if/then/else.

=== Loop

The loop provides the ability to repeat a set of tasks.

image::flow_spec_loop.png[align=center]

-   The target of a *loop* action must be a parent of the initiator
    following the dependency chain; this action goes back to a
    previously executed task.

-   Every task is executed at least once; *loop* operates in a
    *do...while* fashion.

-   The target of a *loop* should have only one explicit dependency. It
    will have different parameters (dependencies) depending if it is
    executed for the first time or not. The cardinality should stay the
    same.

-   The *loop* scope should be a *task block*: the target is a *start
    block* task, and the initiator its related *end block task*.

- The current iteration index (from to 0 to n until `loop` is false) can be accessed via the
    `PA_TASK_ITERATION` <<_workflow_variables,variable>>.

TIP: If you are familiar with programming, you can see the loop as a do/while.

=== Task Blocks

Workflows often relies on *task blocks*. Task blocks are defined by pairs of *start* and *end* tags.

-   Each task of the flow can be tagged either *start* or *end*

-   Tags can be nested

-   Each *start* tag needs to match a distinct *end* tag

Task blocks are very similar to the parenthesis of most programming
languages: anonymous and nested start/end tags. The only difference is
that a parenthesis is a syntactical information, whereas task blocks are
semantic.

The role of task blocks is to restrain the expressiveness of the system
so that a workflow can be statically checked and validated. A treatment
that can be looped or iterated will be isolated in a well-defined task
block.

-   A *loop* flow action only applies on a task block: the initiator of
 the loop must be the end of the block, and the target must be the
 beginning.

-   When using a *continuation* task in an *if* flow action, the *if*
 and *else* branches must be task blocks.

-   If the child of a *replicate* task is a task block, the whole block
 will be replicated and not only the child of the initiator.

=== Control Flow Scripts

To perform a control flow action such as if, replicate or loop, a
*Control Flow Script* is executed on the ProActive node. This script
takes the result of the task as input; meaning a Java object if it was a
Java or Script task, or nothing if it was a native task.

The script is executed on the ProActive node, just after the task's
executable. If the executable is a Java Executable and returns a result,
the variable `result` will be set in the script's environment so that
dynamic decisions can be taken with the task's result as input. Native
Java objects can be used in a Groovy script.

.Decide whether to keep looping or not based on the task's result:
[source,groovy]
----
loop = result
----

Similarly to how parameters are passed through the *result* variable to
the script, the script needs to define variables specific to each action
to determine what action the script will lead to.

-   A *replicate* control flow action needs to define how many parallel
    runs will be executed, by defining the variable `runs`:

[source,groovy]
----
// assuming result is a java.lang.Integer
runs = result % 4 + 1
----

The assigned value needs be a strictly positive integer.

-   An *if* control flow action needs to determine whether the if or the
    else branch is selected, it does this by defining the boolean
    variable `branch`:

[source,groovy]
----
// assuming result is a java.lang.Integer
if (result % 2) {
  branch = "if"
} else {
  branch = "else"
}
----

The assigned value needs to be the string value _if_ or _else_.

-   The *loop* control flow action requires setting the `loop`, which
    will determine whether looping to the statically defined target is
    performed, or if the normal flow is executed as would a continue
    instruction do in a programming language:

[source,groovy]
----
loop = result as Boolean
----

The assigned value needs to be a boolean.

Failure to set the required variables or to provide a valid
control flow script will not be treated gracefully and will result in
the failure of the task.

=== Loop and Replicate awareness

When Control Flow actions such as *replicate* or *loop* are performed,
some tasks are replicated. To be able to identify replicated tasks
uniquely, each replicated task has an *iteration index*, *replication
index*, and a *tag*. In addition to help to identify uniquely, these tags are
useful to filter tasks by iterations for example.


==== Task name

First, those indexes are reflected inside the names of the tasks
themselves. Indeed, task names must be unique inside a job. The indexes
are added to the original task name as a suffix, separated by a special
character.

-   If a task named _T_ is replicated after a *loop* action, the newly
    created tasks will be named _T#1_, _T#2_, etc. The number
    following the _#_ separator character represents the *iteration
    index*.

-   The same scheme is used upon *replicate* actions: newly created
    tasks are named _T*1_, _T*2_, and so on. The number following the
    $$*$$ separator represents the *replication index*.|

-   When combining both of the above, the resulting task names are of
    the form: _T#1*1_, _T#2*4_, etc., in that precise order.


==== Task tag

Tags are assigned automatically by the scheduler when a task is created by
replication from another task. They are designed to reflect the task that
initiated the replication for the first time, the type of replication (loop
or replicate) and the iteration index or replication indexes. So the tag is
formed like this: *(LOOP|REPLICATE)-Name_of_the_initiator-index*.

-   If the task _T1_ initiates a loop that contains the tasks _T2_ and _T3_,
    then the tasks _T2#1_ and _T3#1_ will have the tag *LOOP-T1-1*. The tasks
    _T2#2_ and _T3#2_ will have the tag *LOOP-T1-3*.

-   If the loop is a cron loop, the index is replaced by the resolved time of
    the initiated looping. For example, in a cron loop that was initiated the
    21/12/2015 at 14h00, the task _T1#1_ will have the tag *LOOP-T1#1-21_12_15_14_00*.

-   If the task _T1_ replicates a block that contains the tasks _T2_ and _T3_,
    then the tasks _T2*1_ and _T3*1_ will have the tag *REPLICATE-T1-1*. The
    tasks _T2*2_ and _T3*2_ will have the tag *REPLICATE-T1-2*.

-   If the task _T1#1_, inside a loop, replicates tasks, the new tasks will have
    the tags *REPLICATE-T1#1-1*, *REPLICATE-T1#1-2*, etc...

-   If the replicated task _T1*1_ initiates a loop inside a replicate, the new
    created tasks will have the tags *LOOP-T1*1-1*, *LOOP-T1*1-2*, etc...


==== Task definition

Those indexes are also available as <<_workflow_variables,workflow variables>>. They can be
obtained using the variable names:

* PA_TASK_REPLICATION
* PA_TASK_ITERATION

Here is how to access those variables:

-   *Native Executable arguments:*

``` {.xml}
<staticCommand value="/path/to/bin.sh">
  <arguments>
    <argument value="/some/path/${PA_TASK_ITERATION}/${PA_TASK_REPLICATION}.dat" />
```

-   *Dataspace input and output:*

``` {.xml}
<task name="t1" retries="2">
  <inputFiles>
    <files includes="foo_${PA_TASK_ITERATION}_${PA_TASK_REPLICATION}.dat" accessMode="transferFromInputSpace"/>
  </inputFiles><outputFiles>
    <files includes="bar_${PA_TASK_ITERATION}_${PA_TASK_REPLICATION}.res" accessMode="transferToOutputSpace"/>
```

NOTE: Scripts affected by the variable substitutions are: Pre, Post, Control Flow.
*No substitution will occur in selection scripts or clean scripts.*



==== Task executable

The iteration and replication indexes are available inside the
executables launched by tasks.

In script tasks, the indexes are exported through the following <<_workflow_variables,workflow variables>>:
 `PA_TASK_ITERATION` and `PA_TASK_REPLICATION`.

[source,groovy]
----
int it  = variables.get("PA_TASK_ITERATION")
int rep = variables.get("PA_TASK_REPLICATION")
----

In a similar fashion, environment variables are set when launching a
native executable: `PAS_TASK_ITERATION` and `PAS_TASK_REPLICATION`:

``` {.sh}
#!/bin/sh
myApp.sh /path/to/file/${variables_PAS_TASK_ITERATION}.dat

```

=== Example: Embarrassingly Parallel problem

An http://en.wikipedia.org/wiki/Embarrassingly_parallel[Embarrassingly Parallel problem^] is a problem that is easy
to split into smaller independent tasks. With ProActive Scheduler you can tackle this type of problem with the
<<_replicate>> construct.

TIP: Familiar with http://en.wikipedia.org/wiki/MapReduce[MapReduce^]? Well, a workflow using replication
uses similar concepts.

The http://try.activeeon.com/tutorials/adv.html[Advanced workflows^] is an example of an embarrassingly parallel
problem where the computation is easily distributed across ProActive Nodes.

== Workflow Execution Control

*ProActive Scheduler* supports portable script execution through the *JSR-223* Java
Scripting capabilities. Scripts can be written in any language supported by the underlying
Java Runtime Environment.

They are used in the ProActive Scheduler to:

* Execute some simple *pre*, *post* and *cleaning* processing (pre scripts, post scripts and cleaning scripts)
* Select among available resources the node that *suits the execution* (selection scripts).

[[_selection]]
=== Selection of ProActive Nodes

A selection script provides an ability for the Scheduler to execute tasks on particular ProActive nodes.
E.g. you can specify that a task must be executed on a Unix/Linux system.

A selection script is always executed before the task itself on any candidate node:
the execution of a selection script must set the boolean variable selected,
that indicates if the candidate node is suitable for the execution of the associated task.

A Java helper *org.ow2.proactive.scripting.helper.selection.SelectionUtils* is provided for allowing
user to simply make some kind of selections. Some script samples are available in
`PROACTIVE_HOME/samples/scripts/selection`.

The following example selects only nodes running on Windows:

[source, javascript]
----
importClass(org.ow2.proactive.scripting.helper.selection.SelectionUtils);

/* Check if OS name is Windows */
if (SelectionUtils.checkOSName("windows")) {
    selected = true;
} else {
    selected = false;
}
----

[[_pre_post_clean]]
=== Pre, Post & Clean Scripts

Another functionality is the possibility to define pre and post scripts. For a given task (Java, Script or Native task),
it is possible to launch a script before and after its execution. This possibility can be useful to copy files
to a node, or clean a directory before or after task execution, for example.

This is a way to separate from business code the preparation of execution environment and its cleaning. A good example
is a script that removes files from a specific directory once the task is finished.

.Clean script example
[source, groovy]
----
Files.deleteIfExists(new File("/tmp/working_dir/").toPath())
----

=== Run computation with your system account

It is possible to start a task under the job owner if the system is configured for that purpose.
There are 2 possible ways to run a task under user account
(in any case, the administrator should have
link:../admin/ProActiveAdminGuide.html#_run_as_me[set computing hosts] to authorize
one of the 2 methods) :

* Using your *scheduling login and password* : if computing hosts are configured and user is authorized to run a process under his login and password.
* Using an *SSH key* provided by the administrator : if computing hosts are configured, the administrator should have given user an SSH key.

User must first create a credential containing this key :

----
$ PROACTIVE_HOME/tools/proactive-create-cred -F config/authentication/keys/pub.key -l username -p userpwd -k path/to/private/sshkey -o myCredentials.cred
----

This command will create a new credentials with *username* as login, *userpwd* as password, using Scheduler public key at
`config/authentication/keys/pub.key`
for credentials encryption and using the private SSH key at
`path/to/private/sshkey`
provided by administrator. The new credential will be stored in *myCredentials.cred*

Once created, user must connect the Scheduler using this credential. Then, in order to execute your task under your account
set *runAsMe=true* in the task.

TIP: You can now use <<_third_party_credentials,third party credentials>> to store the SSH key with the special entry named *SSH_PRIVATE_KEY*.

[[_multi_node_task]]
=== Reserve more than one node for a task

To create a <<_mpi_application,multi-nodes>> task often used for MPI applications you need to add a *parallel environment*
to the task. Parallel environment describes how many nodes are needed for a task as well as where these nodes should be
located. For example if you'd like to run 4 processes in parallel it a scope of one task you should specify it in your task

[source, xml]
----
<parallel numberOfNodes="4"/>
----

NOTE: For instance if 4 nodes are running on a given note (often because the host has 4 cores), then
a multi-nodes task that requires 4 nodes might select the 4 workers on this host.

==== Defining a Topology for Multi-Nodes Tasks

In addition to the number of ProActive Nodes you can specify the *nodes network topology*, e.g
the set of nodes within some latency threshold, nodes on the same host and many more.


Here is the list of topologies we support:

* *Arbitrary* topology does not imply any restrictions on nodes location
* *Best proximity* - the set of closest nodes among those which are not executing other tasks.
* *Threshold proximity* - the set of nodes within a threshold proximity (in microseconds).
* *Single Host* - the set of nodes on a single host.
* *Single Host Exclusive* - the set of nodes of a single host exclusively. The host with selected nodes will be reserved for the user.
* *Multiple Hosts Exclusive* - the set of nodes filled in multiple hosts. Hosts with selected nodes will be reserved for the user.
* *Different Hosts Exclusive* - the set of nodes each from a different host. All hosts with selected nodes will be reserved for the user.

=== Handling failures

It's possible to have errors when your workflow is executed. *ProActive Scheduler* provides several mechanisms to deal
with exceptional situations in your workflows.

To understand if a task is successfully finished or not the Scheduler checks its *exit code* (for native tasks) or
*exceptions* (for Java/script tasks). Then, it decides what to do next according to the following parameters:

* *cancelJobOnError* (optional - `false` by default) - defines whether the job must continue when a user exception or
error occurs during the job process. This property can also be defined in each task. If the value of this property
is defined at the job level, each cancelJobOnError property of each task will have this value as the default one
(excepted if this property has been set at the task level). `true` implies for the job to immediately stop
every remaining running tasks if an error occurs in one of the tasks. It is useful when there is no need to go further after a task failure.

* *restartTaskOnError* (optional - `anywhere` by default) - defines whether tasks that have to be restarted will
restart on an other resource. Defining this property will set the restartTaskOnError property of each task to this
value as the default one (excepted if this property has been set at the task level). Possible values are 'anywhere'
or 'elsewhere' meaning respectively that the concerned task will be restart on any available resources or especially
on a different one. A task can be restarted when an exception occurred (Java Task) or an error code is returned (Native Task).

* *maxNumberOfExecution* (optional - `1` by default) - defines how many times tasks are allowed to be restarted.
Defining this property will set the nbMaxOfExecution property of each task to this value as the default one
(excepted if this property has been set at the task level). The value has to be a non-negative and non-null integer.

==== Maximum execution time for a task

A `timeout` (also known as `walltime`) can be set at the task's level to stop a task's execution when the timeout is reached.
The general format of the walltime attribute is `[hh:mm:ss]`, where h is hour, m is minute and s is second.
The format still allows for more flexibility. We can define the walltime simply as `5` which corresponds to
5 seconds, `10` is 10 seconds, `4:10` is 4 minutes and 10 seconds, and so on.

The walltime mechanism is started
just before a task is launched. If a task does finish before its walltime, the mechanism is canceled. Otherwise,
the task is terminated. Note that the tasks are terminated without any prior notice.


=== Cron Tasks
*ProActive Scheduler* supports the execution of time-based tasks or cron tasks. The users can assign a
cron expression to the `loop` variable of a *Loop* in a ProActive Job. All tasks which belong
that Loop will be executed iteratively and indefinitely. The start time of the next iteration
is the next point of time specified by the cron expression.

==== Cron Expression Syntax
The syntax of the follows the UNIX crontab pattern, a string consists of five space-separated segments.
 Please refer http://www.sauronsoftware.it/projects/cron4j/manual.php#p02[cron4j documentation] for further details.

==== Setting up Cron Tasks
Setting up a cron task requires two steps:

* Define a *Loop* with the desired cron tasks
* Assign a cron expression as the `loop` variable value

Example that prints _Hello_ every 10 minutes:
[source, xml]
----
<job name=”cron_job”>
     <genericInformation>
        <info name="START_AT" value="2014-01-01T00:00:00+01:00"/>
    </genericInformation>
    <task name=”cron_task”>
        <scriptExecutable>
            <script>
                <code language="javascript">
                    print("Hello");
                </code>
            </script>
        </scriptExecutable>
        <controlFlow>
            <loop target=”cron_task”>
                <script>
                    loop = “10 * * * *”
                </script>
            <loop>
        </controlFlow>
    </task>
</job>
----

You can find a complete example running a simple task every minutes in this link:examples/cron_task.xml[XML workflow^].

==== Notes

* The execution of the first iteration occurs immediately and does not depend on the cron expression specified.
 However the user can specify a start time for the first iteration using `START_AT` <<_generic_information,generic information>>.
 Its value should be http://en.wikipedia.org/wiki/ISO_8601[ISO 8601^] compliant.

* Each iteration yields one or more task results and the user can query the job state and task states to
retrieve information of each iteration.

* It is assumed that execution time of each iteration is less that time gap specified by the cron expression.
 If the execution time of an iteration is longer, the execution of the next iteration will occur at next point
  of time with respect to the current time. For instance it is possible to observe lesser number of iteration
   executed within a certain time period than number of expected iterations, if some iterations had take longer finish time.

* If the execution of the task defining the loop (where the <controlFlow> block is defined) fails,
 the cron execution is terminated.

* ProActive Scheduler executes any cron task indefinitely. Therefore the state of ProActive Job will remain
 `RUNNING` unless the cron task execution terminates either by the user (for instance by killing the job
  or the task) or due an error in the task execution.

=== Remote Visualization

Using the Scheduler Web Interface, it is possible to access the display of the ProActive Node running a given task.
First remote visualization must be activated via the
link:../admin/ProActiveAdminGuide.html#_rest_api_properties[Scheduler configuration files] (set *novnc.enabled* to true).

NOTE: Remote visualization works via VNC where the REST API will connect to the node running the task, i.e a graphical
application. The VNC output will be forwarded to the your browser and you will be able to interact with the
application.

The task that you want to visualize must output a special string using the following format:
*PA_REMOTE_CONNECTION;JOB_ID;TASK_ID;vnc;HOSTNAME:PORT* where *JOB_ID* must be the current job id, *TASK_ID* the current task id
and *HOSTNAME:PORT* the hostname and port where the VNC server runs.

It is the task's responsibility to print the string.
Here is a link:examples/remote_visualization_script.sh[sample script^] that starts a Xvnc server and runs
 a graphical application.
It can be used in a native task for instance.

In the Scheduler Web Interface, select the running job and use the _Preview_ tab to enable remote visualization.

TIP: Since it runs a graphical application, the task will never exit and run forever. The common use case is that
you want to check manually some results via the graphical application and then exit the application.
The task will then terminate normally.

=== Troubleshoot a Workflow Execution

When a task has *IN_ERROR* status, a right click on it allows the user to select _Mark as finished and resume_. 
This will set the task status as *FINISHED* and then resume job execution: this task won't be executed again, subsequent tasks will execute as if the task executed correctly.
This allows the user to manually perform actions to the *IN_ERROR* task, without cancelling the whole job execution. 


If the task has not *IN_ERROR* status, the _Mark as finished and resume_ option will be in grey, meaning that the action is disabled.


== Workflow Storage and Versioning

The Workflow Catalog provides the storage and versioning of workflows inside Buckets. It also features a searching functionality using a simple query language to fetch workflows based on particular parameters. The Workflow Catalog is a RESTful service. A http://swagger.io/[Swagger] interface is provided to understand and interact with the service.

=== Bucket concept

A Bucket is a collection of Workflows that can be shared between users. The default settings provide the following Buckets:

* Templates (set of Workflows samples publicly readable)

Listing the catalog for existing Buckets is done using the following HTTP request:

    GET http://localhost:8080/workflow-catalog/buckets

It is also possible to list all Workflows inside a particular Bucket using its `bucket_id`:

    GET http://localhost:8080/workflow-catalog/buckets/{bucket_id}/workflows

Then, we can fetch a particular Workflow based on its `workflow_id`:

    GET http://localhost:8080/workflow-catalog/buckets/{bucket_id}/workflows/{workflow_id}

NOTE: By default, the catalog will always return the latest version of the workflows.

=== Workflow versioning

The Workflow Catalog provides versioning of workflows. You can list all the revisions of a particular Workflow using the HTTP request:

    GET http://localhost:8080/workflow-catalog/buckets/{bucket_id}/workflows/{workflow_id}/revisions

You can fetch a Workflow detailed information using its `workflow_id` and `revision_id`:

    GET http://localhost:8080/workflow-catalog/buckets/{bucket_id}/workflows/{workflow_id}/revisions/{revision_id}

A Workflow Revision is created from a ProActive XML <<_glossary_workflow,*Workflow*>> definition.
Beside from the _id_, _name_ and _project_name_ of the Workflow, a few more information are indexed from the XML content such as _<<_generic_information>>_ and _<<_workflow_variables>>_.

More detailed information on how to create or modify Workflows and Buckets are available in the link:../admin/ProActiveAdminGuide.html#_workflow_catalog[Admin guide].


=== Searching for workflows

You can search or filter Workflows and Workflow Revisions by means of Workflow Catalog Query Language (<<_wcql,*WCQL*>>).

Search on the latest versions of Workflows contained in a particular Bucket:

    http://localhost:8080/workflow-catalog/{bucket_id}/workflows?query=...

Search through all versions of a particular Workflow:

    http://localhost:8080/workflow-catalog/{bucket_id}/workflows/{workflow_id}/revisions?query=...

NOTE: More details about how to use pagination and sorting is available on the http://docs.spring.io/spring-data/rest/docs/2.4.2.RELEASE/reference/html/#paging-and-sorting[Spring-data REST documentation].

[[_wcql]]
==== Workflow Catalog Query Language

Our Workflow Catalog Query Language allows to express simple conditions on the indexed information of ProActive XML Workflows.
A search query written in WCQL can combine one or more search clauses with the conjunctions `AND` and `OR`, thus forming an expression.
Like in most query languages, the `AND` conjunction has precedence over `OR`.

===== Clauses

====== Atomic Clause

It is made up of three parts:

* an *Attribute*: `name` or `project_name`
* an *Operator*: `=` or `!=`
* a *Literal Value*

====== Key/Value Clause

It is composed of:

* an *Attribute*: `generic_information` or `variable`
* a *Key/Value Pair*: starts with `(`, ends with `)` and contains between
the last two characters two *Literal Value* separated by a comma.

===== Literal Value

The representation of a String value as a quoted sequence of characters, e.g. _"My First Workflow"_. It can contain a wildcard `*` that substitutes for zero or more characters.

==== Examples

===== Atomic Clauses

    name="My First Workflow"
    project_name="Templates"

===== Key/Value Clauses

    generic_information("Infrastructure", "Amazon EC2")
    variable("CPU", "4")

===== Expressions and Wildcard

Let the following Workflows:
[width="100%",frame="topbot",options="header", cols="30%<"]
|==============================================================================================
| Name                         | Project Name | GI Name | GI Value | Variable Name     | Variable Value
| _My First Workflow_	         | Tutorials    |         |          | 		               |
| _Create OpenStack Instance_  | Deployment   | Infrastructure | OpenStack  | Core		 | 4
| _Stop OpenStack Instance_    | Lifecycle    | Infrastructure | OpenStack  |      		 |
| _New Amazon Instance_        | Deployment   | Infrastructure | Amazon EC2 | Nb_CPU	 | 2
|==============================================================================================

They are matched against these query expressions:
[width="100%",frame="topbot",options="header"]
|=================================================================================================================================
| Expression						                              | Matches
| name = "My First Workflow"						              | _My First Workflow_
| name = "My*"						                            | _My First Workflow_
| project_name = "\*ploy*" 		    		                |_Create OpenStack Instance_ and _New Amazon Instance 1_
| project_name = "\*ploy*" AND variable("\*CPU", "*")	|_New Amazon Instance 1_
|=================================================================================================================================

Evaluation priority is respected through operator precedence (`AND` over `OR`), so the following statement:

    Search for all Workflows that can deploy an OpenStack instance

can be expressed as:

    name="Create OpenStack Instance" OR project_name="Deployment" AND generic_information("Infrastructure", "OpenStack")

Once executed, this query will return a single Workflow named _Create OpenStack Instance_.

== Third-party credentials

=== Overview

Tasks executed by <<_glossary_practive_scheduler,*ProActive
Scheduler*>> might need to use a password or another kind of
credentials to acces third-party services or applications. For example
a user might wish to pass his MySQL password to Native Task which runs
a `mysql` command to dump a database.

In such cases it is often desireable to store the credentials
separately from the <<_glossary_workflow,*Workflow*>>
definition. *ProActive Scheduler* provides such facility.

Third-party credentials in *ProActive Scheduler* are user-defined
key-value pairs of strings stored on the server side in encrypted
form. The credentals are accessible in the tasks executed by the user
via API (Script and Java Tasks) or variable substitution (arguments of
Native Tasks and parameters of Java Tasks).

=== Managing third-party credentials

Methods to add or remove the credentials and to list the stored
credential keys are exposed in both Java and REST APIs.

End users can manage their credentials using the
<<_glossary_scheduler_web_interface,Scheduler Web Interface>> (Portal
-> Manage third-party credentials) or the
<<_scheduler_command_line,Command Line Interface>>.

==== Example CLI usage

Add credential:

    $ ./bin/proactive-client --put-credential MY_MYSQL_PASSWORD mypassword
    Credential "MY_MYSQL_PASSWORD" successfully stored.

List credentials (only keys are listed):

    $ ./bin/proactive-client --list-credentials
    [...]
    MY_MYSQL_PASSWORD

Remove credential:

    $ ./bin/proactive-client --remove-credential MY_MYSQL_PASSWORD
    Credential "MY_MYSQL_PASSWORD" successfully removed.

=== Using third-party credentials

==== In a Script Task

In a Script Task, the `credentials` map contains all user's
credentials:

[source,groovy]
----
// mysqlPassword will contain the value corresponding to "MY_MYSQL_PASSWORD" key
mysqlPassword = credentials.get('MY_MYSQL_PASSWORD')
----

==== In Java Task

In Java, the method `getThirdPartyCredential` of `JavaExecutable`
returns the credential corresponding to the key passed as parameter:

[source,java]
----
public class PrintAndReturnCredentialsTask extends JavaExecutable {
  @Override
  public Serializable execute(TaskResult... results) throws Throwable {
    // mysqlPassword will contain the value corresponding to "MY_MYSQL_PASSWORD" key
    String mysqlPassword = getThirdPartyCredential("MY_MYSQL_PASSWORD");
    [...]
  }
}
----

Another way to use credentials in Java tasks is via parameters. If a
parameter contains a string of the form `$credentials_<credential
key>`, the string is replaced with the value of the corresponding
credential:

[source,xml]
----
<task name="...">
  <javaExecutable class="...">
    <parameters>
      <!-- mysqlPassword will contain the value corresponding to "MY_MYSQL_PASSWORD" key -->
      <parameter name="mysqlPassword" value="$credentials_MY_MYSQL_PASSWORD"/>
    </parameters>
  </javaExecutable>
</task>
----

==== In a Native Task

Finally, a credential can be passed to a Native Task via
argumens. Note that, as with Java Task parameters, the `$credentials_`
prefix is necessary. In the example below, `/bin/echo` will be called
with the value corresponding to the key `MY_MYSQL_PASSWORD` (if the
key is not present, no replacement occurs):

[source,xml]
----
<task name="Task1">
  <nativeExecutable>
    <staticCommand value="/bin/echo" >
      <arguments>
        <argument value="$credentials_MY_MYSQL_PASSWORD"/>
      </arguments>
    </staticCommand>
  </nativeExecutable>
</task>
----

== Scheduler and DataSpace APIs
From a ProActive task, several APIs are accessible via Java objects bound to dedicated variables:

- Scheduler API : using the "schedulerapi" variable, it is possible to interact directly with the scheduler and do several operations such as submitting jobs, waiting for tasks, listing running jobs etc.
- DataSpace API : the "userspaceuri" or "globalspaceuri" variables allow to manipulate files present in User or Global spaces. Operations include listing, uploading, downloading, or deleting files.

=== Scheduler API

From inside a task script, you can use the Scheduler API variable like the following:

[source,groovy]
----
// importing necessary classes
import org.ow2.proactive.scheduler.common.job.*
import org.ow2.proactive.scheduler.common.task.*
import org.ow2.proactive.scripting.*


// connect to the scheduler
schedulerapi.connect()

// create a hello world job
job = new TaskFlowJob()
job.setName("HelloJob")
task = new ScriptTask()
task.setName("HelloTask")
task.setScript(new TaskScript(new SimpleScript("println 'Hello World'", "groovy")))
job.addTask(task)

// submitting the job
jobid = schedulerapi.submit(job)

// Wait for the task termination
taskResult = schedulerapi.waitForTask(jobid.toString(), "HelloTask", 120000)

// displaying the task output
println taskResult.getOutput().getAllLogs(false)

----

The complete API description can be found in the http://doc.activeeon.com/javadoc/latest/org/ow2/proactive/scheduler/task/client/SchedulerNodeClient.html[SchedulerNodeClient JavaDoc].

=== DataSpace API

The traditional way to transfer files from the user or global space to a task is by using file transfer directives as described in chapter <<_data_spaces>>.

Where file transfer directives are sufficient to cover usual cases, it is sometimes necessary to manipulate directly the dataspace API to have a finer control level.

Below is an example use of this api :

[source,groovy]
----
// connect to the user space
userspaceapi.connect()

// push file
inFile = new File("inFile.txt");
inFile.write("HelloWorld")
userspaceapi.pushFile(inFile, "remoteDir/inFile.txt")

// list files

remotefiles = userspaceapi.listFiles("remoteDir", "*.txt"
println remotefiles

// pull File
outFile = new File("outFile.txt")
userspaceapi.pullFile("remote/inFile.txt", outFile)

println outFile.text

----

The complete description of user and global space APIs can be found in the http://doc.activeeon.com/javadoc/latest/org/ow2/proactive/scheduler/task/client/DataSpaceNodeClient.html[DataSpaceNodeClient JavaDoc].


== Fork environment
A fork execution environment is a new Java Virtual Machine (JVM) which is started exclusively to execute a task. Starting a
new JVM means that the task inside it will run in a new environment. This environment can
be set up by the creator of the task. A new JVMs is set up with a new classpath,
new system properties and more customization.

=== Docker fork execution environment
A Docker fork execution environment executes a JVM inside a Docker container. Hence the task
which is executes in the Docker fork execution environment can be customized by the JVM settings
and by the tool-set and isolation provided by Docker containers.

TIP: If your task needs to install new software or updates software, then run it inside a Docker container.
That way other tasks will not be affected by changes, because Docker containers provide isolation so that
the host machine's software stays the same.

==== How to use a fork execution Environment
Select Docker in the ‘Fork Execution Environment’ Dropdown:
sample Docker environment settings will appear.

That settings ensure, that the current task is executed inside a Docker container, or fail if Docker is
 not installed or the user has no permission to run Docker containers.

TIP: If the executing Node has no Docker installed, the task will fail. Selection Scripts can ensure
that tasks are executed only on Nodes which have Docker installed.

===== Procedure
The Fork Environment Script exports a variable `preJavaHomeCmd`, which is picked up by the Node that
 executes the Task. That variable is supposed to be a Docker run command inside a string.
  That string will be split by space and added in front of the fork execution command. As an example:
----
/usr/bin/java -cp [Classpath] [ExecutedClass]
----
And the Docker run command is:
----
docker run java
----
Then both will be combined to:
----
 docker run java /usr/bin/java -cp [Classpath] [ExecutedClass]
----

The combined command will execute a JVM inside a docker container.
Internally the command is split into docker, run, java, /usr/bin/java, -cp, [Classpath], [ExecutedClass].
 That is important to know because the fork execution command is split by spaces.
  That means, that paths can’t contain spaces. The Docker container mounts the ProActive home and a
   folder in the temp directory of the operating system. Those cannot contain spaces, because if they
    do then the fork execution command will be split wrong and fail.


== Calendar Integration

include::./references/CalendarServiceReference.adoc[]

== Reference

=== Job and task specification

Workflows are written in XML and we provide a XSD grammar to help you write and validate them.
The Workflows XSD is available link:http://www.activeeon.com/public_content/schemas/proactive/jobdescriptor/3.3/schedulerjob.xsd[here, window="_blank"]
and you can also find the documentation link:schedulerjob.html[here, window="_blank"].

TIP: Setup your IDE to use the http://www.activeeon.com/public_content/schemas/proactive/jobdescriptor/3.3/schedulerjob.xsd[Workflow XSD^],
you will benefit from live validation and completion!

=== Variables quick reference
include::./references/VariablesReference.adoc[]

=== Topology Types
include::./references/TopologyTypes.adoc[]

[[_scheduler_command_line]]
=== Command Line
include::../CLI.adoc[]

include::../Dedication.adoc[]
